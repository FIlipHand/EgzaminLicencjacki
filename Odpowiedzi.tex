\documentclass[a4paper,12pt,oneside]{book}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{{./images}}
\usepackage[shortlabels]{enumitem}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{pdfpages}

\usepackage{tikz}
%\usepackage{etoolbox} % for \ifthen
\usepackage{listofitems} % for \readlist to create arrays
\usetikzlibrary{arrows.meta} % for arrow size
\usepackage[outline]{contour} % glow around text
\contourlength{1.4pt}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{tabularx}


\tikzset{>=latex} % for LaTeX arrow head
\usepackage{xcolor}
\colorlet{myred}{red!80!black}
\colorlet{myblue}{blue!80!black}
\colorlet{mygreen}{green!60!black}
\colorlet{myorange}{orange!70!red!60!black}
\colorlet{mydarkred}{red!30!black}
\colorlet{mydarkblue}{blue!40!black}
\colorlet{mydarkgreen}{green!30!black}
\tikzstyle{node}=[thick,circle,draw=myblue,minimum size=22,inner sep=0.5,outer sep=0.6]
\tikzstyle{node in}=[node,green!20!black,draw=mygreen!30!black,fill=mygreen!25]
\tikzstyle{node hidden}=[node,blue!20!black,draw=myblue!30!black,fill=myblue!20]
\tikzstyle{node convol}=[node,orange!20!black,draw=myorange!30!black,fill=myorange!20]
\tikzstyle{node out}=[node,red!20!black,draw=myred!30!black,fill=myred!20]
\tikzstyle{connect}=[thick,mydarkblue] %,line cap=round
\tikzstyle{connect arrow}=[-{Latex[length=4,width=3.5]},thick,mydarkblue,shorten <=0.5,shorten >=1]
\tikzset{ % node styles, numbered for easy mapping with \nstyle
	node 1/.style={node in},
	node 2/.style={node hidden},
	node 3/.style={node out},
}
\def\nstyle{int(\lay<\Nnodlen?min(2,\lay):3)} % map layer number onto 1, 2, or 3

\def\shrug{\texttt{\raisebox{0.75em}{\char`\_}\char`\\\char`\_\kern-0.5ex(\kern-0.25ex\raisebox{0.25ex}{\rotatebox{45}{\raisebox{-.75ex}"\kern-1.5ex\rotatebox{-90})}}\kern-0.5ex)\kern-0.5ex\char`\_/\raisebox{0.75em}{\char`\_}}}

\renewcommand\thechapter{\Roman{chapter}}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}

\begin{document}

	\includepdf{Odpowiedz-cover-page.pdf}

	\tableofcontents
	\newpage
	
	\chapter{Pytania - dr. hab. Bogdan Księżopolski}
	
		\section{Sieci i programowanie sieciowe}
			\subsection{Protokoły TCP i UDP - porównanie i zastosowanie.}
			
				\subsubsection*{TCP}
				
				Protokół TCP lub Transmission Control Protocol jest protokołem zorientowanym na połączenie, znajdującym się w warstwie transportowej modelu TCP / IP. Nawiązuje połączenie między komputerem źródłowym a docelowym przed rozpoczęciem komunikacji.
				
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.30]{tcp.png}
					\caption{TCP}
				\end{figure}
				
				Jest wysoce niezawodny, ponieważ wykorzystuje 3-drożną kontrolę uzgadniania, przepływu, błędu i przeciążenia. Zapewnia to, że dane wysyłane z komputera źródłowego są dokładnie odbierane przez komputer docelowy. Jeśli w przypadku, otrzymane dane nie są w odpowiednim formacie, to TCP ponownie przesyła dane.
				Poniższe protokoły używają TCP do transmisji danych:
				\begin{itemize}
					\item HTTP
					\item HTTPs
					\item FTP
					\item SMTP
				\end{itemize}
				
				\subsubsection*{UDP}
				
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.25]{udp.jpg}
					\caption{UDP :D}
				\end{figure}
				
				Protokół UDP lub User Datagram Protocol to bezpołączeniowy protokół znajdujący się w warstwie transportowej modelu TCP / IP. Nie ustanawia połączenia ani nie sprawdza, czy komputer docelowy jest gotowy do odbioru, czy też nie, po prostu przesyła dane bezpośrednio. Protokół UDP służy do przesyłania danych z większą szybkością. Jest mniej niezawodny i dlatego jest używany do przesyłania danych, takich jak pliki audio i wideo.
				UDP nie gwarantuje ani dostarczenia danych, ani nie przesyła utraconych pakietów.	
				
							
			
			\newpage\subsection{Protokół IP.}
				\subsubsection{IP (Internet Protocol)}
				Protokół internetowy jest protokołem komunikacyjnym warstwy Internet w modelu TCP/IP (odpowiada warstwie sieciowej modelu OSI). Protokół ten definiuje zasady i sposoby postępowania urządzeń sieciowych w celu nawiązania połączenia, utrzymania go i samej transmisji danych. Protokół IP stosowany jest w większości rodzajów sieci, w tym w sieci lokalnej i sieci Internet (każdy host, np. komputer, posiada swój własny, unikalny dla sieci adres IP).
				
				Dane z użyciem protokołu IP transmitowane są w pakietach (paczkach danych). Nie gwarantuje on jednak dotarcia danych do celu czy utrzymania kolejności pakietów. Może się zdążyć, ze odbiorca otrzyma kilkukrotnie ten sam pakiet z całej paczki danych, pakiety dotrą w innej kolejności lub nie dotrą w ogóle. W celu zapewnienia prawidłowej transmisji stosuje się różne techniki w wyższej warstwie, np. z użyciem protokołu TCP.
				
				Ponieważ każdy host w sieci posiada swój własny unikalny adres IP, obecnie wykorzystywana czwarta wersja protokołu (v4) okazała się niewystarczająca i brakuje wolnych adresów IP. W tym celu utworzona została wersja szósta (v6) znacznie zwiększająca ilość różnych adresów IP. Same adresy IP dzielone są na kilka grup z których 3 najważniejsze to adresy publiczne, adresy prywatne (do wykorzystania w sieciach domowych, np. 192.168.1.1), oraz adresy pętli zwrotnej (np. 127.0.0.1).
				
				W skrócie:
				\begin{itemize}
					\item protokół komunikacyjny z warstwy trzeciej (sieci)
					\item jest to protokół bezpołączeniowy
					\item głównym zadaniem tego protokołu jest przypisywanie każdemu urządzeniu
					sieciowemu adresu IP i wybór trasy w celu przesłania pakietów z danymi (w
					przypadku problemów w przesyłaniu pakietów protokół wybierze trasy alternatywne
					do przesłania pakietów)
					\item nie zapewnia dostarczania pakietów (nie posiada mechanizmów retransmisji, lecz na
					szczęście za to odpowiadają protokoły z warstw wyższych)
				\end{itemize}
			\subsubsection{Klasy IP}
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.65]{ip-classes.jpg}
					\caption{Klasy IP}
				\end{figure}
			\subparagraph{Adresy klasy A} przeznaczone są dla dużych sieci. Pierwszy bit oktetu w którym zawarty jest adres sieci jest równy 0. W związku z tym adresy sieci mogą przyjmować wartości od 0 do 127. Sieci 0 i 127 są zarezerwowane, więc do wykorzystania pozostają sieci od 1 do 126. W każdej sieci należącej do klasy A możemy wyodrębnić 16777216 adresów (liczba urządzeń będzie o 2 mniejsza, ale o tym w dalszej części artykułu). Klasa 127.0.0.0 wykorzystywana jest na potrzeby pętli zwrotnej, tj. umożliwia wysyłanie pakietów do samego siebie. Maska standardowa dla tej klasy to 255.0.0.0.
			
			\subparagraph{Adresy klasy B} przeznaczone są do sieci średniej wielkości. Adres sieci zawarty jest w dwóch oktetach. Pierwsze dwa bity pierwszego oktetu wynoszą 10. W każdej sieci należącej do tego klasy można wyróżnić 65536 adresów (65534 urządzenia). Do tej klasy należą adresy sieci od 128 do 191 w ujęciu dziesiętnym. Maska standardowa dla tej klasy to 255.255.0.0.
			
			\subparagraph{Adresy klasy C} przeznaczone są dla małych sieci, gdyż każda sieć może posiadać „jedynie” 256 adresów (254 urządzenia). Na adres sieci w sieciach należących do tej klasy przeznaczone są 3 oktety. Pierwsze trzy bity adresu wynoszą 110, w związku z tym do klasy tej należą adresy od 192 do 223 dziesiętne. Maska standardowa dla tej klasy to 255.255.255.0.
			
			\subparagraph{Klasa D} została zarezerwowana na potrzeby rozsyłania grupowego przy użyciu adresów IP. Adres należący do tej klasy umożliwia przekierowanie pakietów do zdefiniowanej wcześniej grupy odbiorców. Dzięki temu możliwe jest przesłanie danych równocześnie do wielu odbiorców. Adresy tej klasy wykorzystywane są np. przez protokoły routingu. Pierwsze cztery bity adresu IP są równe 1110. Adresy należące do tej klasy zawierają się w przedziale od 224 do 239.
			
			\subparagraph{Adresy należące do klasy E} zostały zarezerwowane przez Internet Engineering Task Force na potrzeby badawcze, wobec tego nie są dostępne publicznie. Pierwsze cztery bity adresu klasy E mają wartość 1111, w związku z tym adresy tej klasy zawierają się w przedziale od 240 do 255 dziesiętnie.
			\subsubsection{Prywatne adresy IP}
				Adresy prywatne wg klas:
				\begin{itemize}
					\item Klasa A – 10.0.0.0 – 10.255.255.255 z maską 255.0.0.0
					\item Klasa B – 172.16.0.0 – 172.31.255.255 z maską 255.255.0.0
					\item Klasa C – 192.168.0.0 – 192.168.255.255 z maską 255.255.255.0
				\end{itemize}
			\subsubsection{Rodzaje trasowania protokołu IP}
			\begin{enumerate}
				\item Anycast - dane są wysyłane do (topologicznie) najbliższego odbiorcy
				\item Broadcast - dane wysyła do wszystkich możliwych hostów
				\item Multicast - dane są wysyłane do wielu wybranych hostów (np. do hostów należących
				do jednej grupy)
				\item Unicast - dane są wysyłane do jednego odbiorcy
				\item Geocast - dane są wysyłane do wielu wybranych hostów należących do jednej strefy
				geograficznej
			\end{enumerate}
			\newpage\subsection{Modele sieci komputerowych.}
				Patrz pytanie \ref{model}.
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.45]{najman.jpg}
					\caption{najman.jpg}
				\end{figure}
			\newpage\subsection{Porównanie protokołów IPv4 i IPv6.}
				\begin{table}[h!]
					\centering
					\renewcommand*{\arraystretch}{2}
					\resizebox{\textwidth}{!}{%
						\begin{tabularx}{\linewidth}{>{\hsize=.5\hsize}X X X}
							\toprule
							& IPv4                             & IPv6                                                                   \\ \midrule
							Adres                               & 32 bity (4 bajty)                & 128 bitów (16 bajtów)                                                  \\
							Zapis adresu &
							nnn.nnn.nnn.nnn , gdzie nnn reprezentuje oktet (bajt) i może być liczbą w systemie dziesiętnym &
							xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxx x , gdzie x jest liczbą w systemie szesnastkowym \\
							Bity poświęcone na sieć i na hosta  & A - 8:24, B - 16:16, C - 24:8    & 64:64                                                                  \\
							Długość nagłówka                    & 20 bajtów                        & 40 bajtów                                                              \\
							Pole "suma kontrolna"               & Jest (wymagany)                  & Brak (zamiast tego pola jest błąd)                                     \\
							IPSec (w kontekście bezpieczeństwa) & Opcjonalne                       & Obowiązkowy                                                            \\
							Identyfikacja przepływu danych &
							Brak (czyli brak QoS {[}jakość usług{]}) &
							Występuje, a wykryty przepływ jest przekazywany na router \\
							Fragmentacja                        & Wykonywana przez hosta i routery & Wykonywana przez hosty                                                 \\
							Konfiguracja adresów                & Manualna lub DHCP                & SLAACK wykorzystujący ICMPv6 lub DHCPv6                                \\
							Uzyskiwanie MAC z IP &
							Zapytanie ARP na Broadcast &
							Wysyłanie zapytania Multicast Neighbor Solicitation (to taki rodzaj zapytania multicast do sąsiadów) \\
							Broadcast                           & Tak                              & Nie (występuje tutaj adres “link-local” który może zastąpić broadcast) \\
							Multicast                           & Tak                              & Tak                                                                    \\ \bottomrule
						\end{tabularx}%
					}
					\label{tab:my-table}
				\end{table}
			\newpage\subsection{Format pakietu IP (poszczególne pola, zastosowanie).}
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.65]{ip-datagram.jpg}
					\caption{Datagram IPv4}
				\end{figure}
				\begin{description}
					\item[Wersja] - w tym polu nagłówka znajduje się wersja protokołu IP, w przypadku IPv4 znajduje się tam cyfra 4
					\item[IHL] - długość nagłówka pakietu IP wyrażona w postaci liczby czterobajtowych części
					\item[Typ usługi] – określa priorytet pakietu
					\item[Długość całkowita] – pole zawiera całkowitą długość pakietu (nagłówek + dane), maksymalna długość pakietu to 65535 bajtów
					\item[Identyfikator ]  – pole zawiera unikatory identyfikator dla każdego pakietu wykorzystywany do połączenia pakietów w strumień danych
					\item[Flagi] – określa między innymi czy pakiet może być fragmentowany
					\item[Przesunięcie fragmentu] – umożliwia złożenie pakietu w całość pakietu, określają miejsce danego fragmentu w całym pakiecie
					\item[Czas życia (TTL – Time To Live)] – ilość przeskoków przez które może pakiet przejść zanim zostanie odrzucony (urządzenia przez które przechodzi dany pakiet zmniejszają tą wartość o 1)
					\item[Protokół ] – to pole zawiera informacje jaki protokół warstwy transportowej został wykorzystany (TCP, UDP, ICMP lub inne)
					\item[Suma kontrolna nagłówka] – gdy odbiorca dostanie pakiet, sprawdza jego poprawność obliczając sumę kontrolną i porównując ją z sumą kontrolną zapisaną w nagłówku
					\item[Adres źródłowy i adres docelowy ] – zawierają adresy IP urządzeń które przesyłają między sobie dane zapisane w formacie binarnym
				\end{description}
			\newpage\subsection{Ethernet.}
				\subparagraph{Ethernet} - jest to standard wykorzystywany (głównie) do budowy sieci lokalnych LAN
				(należy pamiętać że Ethernet jest najpopularniejszy. Jest jeszcze np. Token Ring, FDDI)
				Opisuje on sposób reprezentacji danych w postaci ramek, które są przesyłane przez
				warstwę fizyczną (czyli przez kable sygnałami 0 i 1)
				
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.45]{ethernet.png}
					\caption{Schemat sieci ethernet}
				\end{figure}
				
				Klasyczne cechy charakteryzujące sieć Ethernet:
				\begin{itemize}
					\item parametry czasowe
					\item format ramki
					\item proces transmisji
					\item podstawowe zasady podczas tworzenia sieci Ethernet
				\end{itemize}
			
				Zalety Ethernet::
				\begin{itemize}
					\item łatwy w implementacji
					\item niski koszt implementacji
					\item niezawodność
					\item zdolny do przyjmowania nowych technologii
				\end{itemize}
			
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.45]{ramka-ethernet.png}
					\caption{Ramka Ethernet}
				\end{figure}
			\newpage\subsection{Protokoły warstwy aplikacji.}
				Najważniejsze protokoły z warstwy aplikacji:
				\begin{itemize}
					\item DNS (Domain Name System; port: 53) - protokół do uzyskiwania adresów IP z nazw
					domenowych (czyli zamiana google.com na 32.194.195.90)
					\item HTTP (HyperText Transfer Protocol; port: 80) - protokół przesyłania dokumentów
					hipertekstowych - czyli pliki HTML i dołączone do nich zasoby (obrazki, pliki do
					pobrania, formularze, itd.)
					\item HTTPS (HyperText Transfer Protocol Secure; port: 443) - szyfrowana wersja
					protokołu HTTP przy wykorzystaniu SSL/TLS
					\item SMTP (Simple Mail Transfer Protocol; port 25) - protokół do wysyłania wiadomości
					E-mail i załączników
					\item POP3 (Post Office Protocol; port 110) - protokół do odbierania poczty E-mail. Klient
					poczty pobiera całe wiadomości z serwera pocztowego (i od razu stamtąd usuwa).
					\item IMAP (Internet Message Access Protocol; port: 143) - protokół do odbierania poczty
					E-mail. Klient poczty pobiera nagłówki wiadomości z serwera pocztowego, a
					wiadomość jest pobierana gdy użytkownik będzie chciał otworzyć tą wiadomość.
					Wymaga stałego dostępu do internetu lecz umożliwia dostęp do poczty z wielu
					urządzeń
					\item Telnet (Telecommunication Network; port: 23) - protokół który emuluje środowisko
					terminala w celu komunikacji ze zdalnym urządzeniem (np. wysłanie E-mail)
					\item FTP (File Transfer Protocol; porty: 20, 21) - jest to protokół (typu klient-serwer) do
					przesyłania plików
					\item DHCP (Dynamic Host Configuration Protocol; port: 67) - protokół do dynamicznej
					konfiguracji urządzeń (przydziela: adres IP, adres bramy domyślnej, adresy
					serwerów DNS)
					\item SSH (Secure Shell; port: 22) - protokół który emuluje środowisko terminala w celu
					komunikacji ze zdalnym urządzeniem wraz z zapewnieniem szyfrowania (następca
					Telnet)
					\item NFS (Network File System; port: 2049) - protokół który udostępnia dyski sieciowe
					(system plików). Chodzi o to że komputery nie mają dysków twardych, a wszystkie
					dane sa na serwerze.
					\item SNMP (Simple, Network Management Protocol; port: 161) - protokół który służy do
					konfiguracji sieci, zbierania informacji o sieci oraz do zarządzania siecią
					\item SMB (Server Message Block; porty: 137, 138, 139, 445) - protokół do udostępniania
					zasobów (np. pliki, skanery, drukarki lub nawet zdalne korzystanie z kart graficznych)
				\end{itemize}
			\newpage\subsection{Charakterystyka modelu OSI i TCP/IP.}
			\label{model}
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.45]{osi-tcp.png}
					\caption{OSI - TCP/IP}
				\end{figure}
				\subsubsection{OSI}
				\subparagraph{Model ISO/OSI} (International Organization for Standardization / Open Systems
				Interconnection) - to standard opisujący komunikację sieciową oraz jej etapy. Jest on znany
				jako “model odniesienia” który służy do analizy (i zrozumienia) komunikacji.
				
				Warstwy:
				\begin{enumerate}
					\item \textbf{Warstwa fizyczna} - zaliczają się do niej wszystkie media transmisji danych (np.
					kable, fale radiowe) oraz sposób przesyłania przez nich informacji (np. jaka
					częstotliwość lub amplituda). 
					\item \textbf{Warstwa łącza danych} - przeprowadza ramkowanie danych (dodawanie nagłówka
					do danych) i przesyła je przez warstwę fizyczną. W nagłówku zawarty jest adres
					MAC nadawcy oraz odbiorcy (host zna adresy MAC swoich najbliższych sąsiadów).
					Przykładowy protokół: PPP, Ethernet, STP
					\item \textbf{Warstwa sieci} - w tej warstwie tworzone są pakiety (dane + nagłówek IP).
					Wykonywane jest tutaj adresowanie logiczne, routing oraz szukanie najlepszej
					ścieżki.\\
					Przykładowe protokoły: ARP, ICMP, IPv4, IPv6, BGP, RIP, OSPF
					\item \textbf{Warstwa transportowa} - tworzy ona segmenty danych (nagłówek zawierający
					numer portów + dane) i wykorzystuje do nich przesyłu przez protokół UDP lub TCP.
					Mogą tutaj występować mechanizmy zapewniające dostarczanie danych jak np.
					retransmisja (TCP ma, a UDP tego nie ma).\\
					Przykładowe protokoły: TCP, UDP, SSL/TLS
					\item \textbf{Warstwa sesji} - nie modyfikuje danych lecz zarządza ona sesją i synchronizacją
					danych. Mając jakieś dane wie ona do jakiej aplikacji przesłać te dane (umożliwia
					komunikację między aplikacjami [end-to-end]).\\
					Przykładowe protokoły: NetBIOS, NFS, PAP
					\item \textbf{Warstwa prezentacji} - polega na normalizacji danych według ustalonych
					standardów poprzez konwersję (zamianę), kompresję, szyfrowanie.\\
					Przykładowe protokoły: SSl, TLS, MIME
					\item \textbf{Warstwa aplikacji} - tutaj działają aplikacje które widzi użytkownik służące do
					przyjmowania i wyświetlania danych użytkownika oraz przy wykorzystaniu gniazd do
					przyjmowaniu danych z sieci i wysyłaniu danych do sieci\\
					Przykładowe protokoły: HTTP, FTP, POP3, SNMP
				\end{enumerate}
			
			\subsubsection{TCP/IP}
			\subparagraph{Model TCP/IP}- model określany inaczej jako “model protokołów”, gdzie każda warstwa
			wykonuje konkretne zadania.
			
			Warstwy:
			\begin{enumerate}
				\item \textbf{Warstwa dostępu do sieci} - służy ona do przekazywania danych między
				urządzeniami sieciowymi (karty sieciowe, modemy) za pośrednictwem medium
				fizycznym (np. kable)\\
				Odpowiada ona warstwie fizycznej i łącza danych z modelu OSI.
				\item \textbf{Warstwa internetu} - w tej warstwie występują routery opierające się o adresy IP i
				dokonujące trasowania (wyszukiwanie najlepszej trasy do odbiorcy).
				Występują tutaj protokoły takie jak: IP, ARP, ICMP (do diagnostyki), IGRP (do
				transmisji grupowej).\\
				Odpowiada ona warstwie sieci z modelu OSI.
				\item \textbf{Warstwa transportowa} - służy ona do obsługi komunikacji oraz jej zabezpieczenia
				(czyli wykorzystanie np. retransmisji danych). Ta warstwa wykorzystuje porty dzięki
				czemu wie z jakiej aplikacji przychodzą dane, a podczas odbierania do jakiej aplikacji
				przesłać dane. Występuje tutaj protokół TCP oraz UDP.\\
				Odpowiada ona warstwie transportowej z modelu OSI.
				\item \textbf{Warstwa aplikacji} - w tej warstwie występują procesy oraz aplikacje z których
				korzystają użytkownicy (np. serwer WWW, przeglądarka internetowa). Działają tutaj
				protokoły tj. HTTP, FTP, Telnet.\\
				Odpowiada ona warstwie sesji, prezentacji i aplikacji z modelu OSI.
			\end{enumerate}
			
			\newpage\subsection{Rodzaje i przykłady nagłówków HTTP.}
				Nagłówki - to informacja niosąca dodatkową treść przesyłana w zapytaniach oraz
				odpowiedziach. Są one oddzielone między sobą symbolem”\textbackslash r\textbackslash n”.
				
				Najpopularniejsze nagłówki:
				\begin{itemize}
					\item Host - identyfikuje aplikację której dotyczy to zapytanie (pod jednym IP jakiegoś
					serwera może być wiele aplikacji i należy to doprecyzować)
					
					Przykład: Host: httpbin.org
					\item User-Agent - zawiera informacje o kliencie użytkownika (np. przeglądarka i jej
					wersja). Może to być istotna informacja do wygenerowania odpowiedzi.
					
					Przykład: User-Agent: Mozilla/5.0 (X11; U; Linux i686; pl-PL; rv:1.7.10) Gecko/20050717 Firefox/1.0.6
					\item Connection - w zapytaniu informuje serwer co on powinien zrobić po wysłaniu
					odpowiedzi (np. “close” - zamknij po wysłaniu odpowiedzi; “keep-alive” - utrzymaj
					połączenie i czekaj na kolejne zapytania)
					
					Przykład: Connection: keep-alive
					\item Podstawowe nagłówki odpowiedzi:
					\begin{itemize}
						\item Date - aktualna data serwera np. Date: Tue, 15 Nov 1994 08:12:31 GMT
						\item Server - nazwa serwera, (czasem i wersja) np. Server: Apache/2.4.1 (Unix)
						\item Expires - data po której dane na stronie będą nieaktualne i będą wymagały
						odświeżenia (jak expires jest za godzinę to przeglądarka wie, że przez
						najbliższą godzinę nie trzeba znowu wysyłać żądania, można załadować
						wersję strony z dysku) 
						
						np. Expires: Thu, 01 Dec 1994 16:00:00 GMT
						\item Last-Modified - data ostatniej modyfikacji 
						
						np.	Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
					\end{itemize}
					\item Nagłówki danych - określają typ oraz kodowanie danych. Zaczynają się one od
					wyrażenia Content
						\begin{itemize}
							\item Content-Type - określa typ danych i ich kodowanie 
							
							np. text/html; charset=ISO-8859-2
							\item Content-Encoding - określa dodatkowe kodowanie danych które je
							modyfikuje (np. kompresja) 
							
							np. Content-Encoding: gzip
							\item Content-Language - określa język dokumentu 
							
							np. Content-language: en, pl
							\item Content-Length - określa rozmiar przesyłanych danych (nie licząc
							nagłówków) 
							
							np. Content-Length: 30
						\end{itemize}
					\item Nagłówki negocjacji - służą do informowania serwera jaki format kodowania
					akceptuje klient np. gdu klient nie obsługuje gzip to jak serwer wyśle dane w tym
					formacie to są one bezużyteczne.
					
					\begin{itemize}
						\item Accept - służy do informowania serwera jakie typy danych obsługuje klient
						np. Accept: application/xhtml+xml, application/xml, text/xml;q=0.7,
						text/html;q=0.5, text/plain;q=0.3
						Można dodać priorytet (czyli takie które najlepiej pasuje klientowi)
						\item Accept-Charset - informuje o preferowanych przez klienta formatów
						kodowania np. Accept-Charset: utf-8, iso-8859-13;q=0.8
						Można dodać priorytet.
						\item Accept-Encoding - informuje o obsługiwanych przez klienta dodatkowych
						kodowaniach np. Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
						Można dodać priorytet.
					\end{itemize}
					\item Nagłówki warunkowe - informuje serwer aby on przesłał dane jeśli jest spełniony
					warunek poprzedzony wyrażeniem “if”
					\begin{itemize}
						\item If-Modified-Since - zwróci odpowiedź jeśli zasób został zmodyfikowany od
						konkretnej daty np. If-Modified-Since: Sat, 29 Jan 2017 19:43:31
						\item If-Unmodified-Since - serwer odpowie jeśli zasób nie został zmodyfikowany
						od konkretnej daty np. If-Unmodified-Since : Sat, 29 Jan 2017 19:43:31
					\end{itemize}
					\item Nagłówki ciasteczek - służą one do tworzenia i obsługi ciasteczek. ciasteczka są to
					informacje dla serwera przechowywane u klienta
					\begin{itemize}
						\item Set-Cookie - jest on zawarty w odpowiedzi serwera (może zawierać np. ID
						sesji) np. Set-Cookie: sessionid=el4ukv0kqbvoirg7nkp4dncpk3\&user=admin
						\item Cookie - jest to nagłówek wysyłany podczas żądania wysyłającą ciasteczko
						np. Cookie: sessionid=el4ukv0kqbvoirg7nkp4dncpk3\&user=admin
					\end{itemize}
				\end{itemize}
			\newpage\subsection{Protokół WebSocket.}
				\subparagraph{WebSocket} – jest protokołem komunikacyjnym, zapewniającym dwukierunkowy kanał wymiany danych poprzez pojedyncze połączenie TCP. WebSockets różni się od protokołu HTTP. Oba protokoły są zlokalizowane na 7 warstwie w modelu OSI i zależą od TCP na warstwie 4. Pomimo faktu, że są one różne, standard RFC 6455 mówi, że WebSocket został zaprojektowany do działana na portach 80 i 443 przypisanych do HTTP, a także wspierać funkcje proxy i pośredników (intermediaries). Aby osiągnąć kompatybilność z HTTP, handshake WebSocket’u wykorzystuje nagłówek HTTP Upgrade[2], aby przełączyć komunikację z protokołu HTTP na WebSockets.
				
				Aby ustanowić połączenie typu WebSocket, klient musi najpierw wysłać żądanie typu handshake, dla którego serwer zwraca odpowiednią odpowiedź, jak pokazane jest to w przykładzie poniżej.
				
				Zarówno w żądaniu klienta, jak i odpowiedzi serwera każda linia wiadomości kończy się znakiem nowej linii (\textbackslash r \textbackslash n) – identycznie jak ma to miejsce w przypadku protokołu HTTP. Dodatkowo na samym końcu żądania/odpowiedzi musi znajdować się pusta linia.
				
				Żądanie klienta:
				\begin{lstlisting}[language=]
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
				\end{lstlisting}
			
			Odpowiedź serwera:
			\begin{lstlisting}[language=]
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
			\end{lstlisting}
		
			Handshake rozpoczyna się od żądania/odpowiedzi HTTP, dzięki czemu dany serwer może obsługiwać połączenia HTTP, a także WebSocket na tym samym porcie. Po nawiązaniu połączenia komunikacja przełącza się na dwukierunkowy protokół binarny, który nie jest już zgodny z protokołem HTTP.
			
			Oprócz nagłówka Upgrade klient wysyła również nagłówek Sec-WebSocket-Key zawierający losowe bajty zakodowane w standardzie base64, na co serwer odpowiada, podając hash tego klucza w nagłówku Sec-WebSocket-Accept. Ma to na celu zapobieganie sytuacji, gdzie np. serwer/proxy buforujący wyśle ponownie całą zapisaną konwersację innemu klientowi, podczas gdy ten nie miał de facto styczności z właściwym serwerem. Proces polega na tym, że funkcja szyfrująca dodaje stały ciąg znaków 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 do wartości podanej w nagłówku Sec-WebSocket-Key klienta (nie jest on dekodowany z base64), a następnie stosuje algorytm szyfrujący SHA-1, by na samym końcu zakodować uzyskaną wartość używając base64.
			
			Gdy połączenie jest już ustanowione, klient i serwer mogą wysyłać sobie dane w formie binarnej lub tekstowej w postaci tzw. ramek w trybie pełnego dupleksu. Sama ramka ma niewielki narzut, dodając jedynie mały nagłówek po którym znajdują się docelowe dane. Transmisje WebSocket są opisywane jako „wiadomości”, w których pojedyncza wiadomość może być opcjonalnie podzielona na kilka ramek. Pozwala to na wysyłanie wiadomości, w których dostępne są dane początkowe, ale nie jest znana pełna długość wiadomości (wysyła są jedna ramka danych za drugą, aż do osiągnięcia końca i zakończenia bitem FIN). Dzięki rozszerzeniom protokołu można to również wykorzystać do multipleksowania kilku strumieni jednocześnie (na przykład w celu uniknięcia monopolizowania użycia gniazda dla pojedynczego dużego ładunku).
		
		
			\newpage\subsection{\color{red}Serwer zdarzeniowy, a wielowątkowy. Charakterystyka i porównanie.}
				a
		
		\newpage\section{Bezpieka}
			\subsection{\color{red}Infrastruktura klucza publicznego - charakterystyka.}
				a
			
			\newpage\subsection{Kryptografia symetryczna oraz asymetryczna - charakterystyka.}
				
				\subsubsection*{Kryptografia symetryczna}
				
				W kryptografii symetrycznej szyfrowanie i deszyfrowanie wykonywane jest przy użyciu tego samego klucza. W niektórych algorytmach wykorzystywane są dwa klucze, jednak muszą one być od siebie zależne w taki sposób, że znając jeden z nich, można wygenerować drugi.
				
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.45]{krypt_sym.png}
					\caption{Zasada działania kryptografii symetrycznej}
				\end{figure}
				
				W celu zapewnienia bezpiecznej komunikacji, algorytm szyfrowania musi być tak skonstruowany, żeby odtworzenie tekstu jawnego bez znajomości klucza było zadaniem trudnym obliczeniowo. Dodatkowym wymaganiem jest tajność klucza – przed rozpoczęciem wymiany wiadomości, należy opracować protokół uzgadniania lub przekazywania klucza.
				
				Algorytmy szyfrowania symetrycznego możemy podzielić na algorytmy blokowe i strumieniowe. Pierwsze z nich przekształcają blok danych ustalonej długości, traktując go jako całość, na szyfrogram o tej samej liczbie bitów. Szyfry strumieniowe przyjmują natomiast ciąg (strumień) danych. Algorytmy kryptografii symetrycznej są szybkie, zwykle wymagają też mniejszej mocy obliczeniowej niż algorytmy asymetryczne. Powszechnie stosowanym szyfrem symetrycznych jest \textbf{AES}.
				
				\subsubsection*{Kryptografia asymetryczna}
				
				Kryptografia asymetryczna to rodzaj kryptografii, w którym jeden z używanych kluczy jest udostępniony publicznie. Każdy użytkownik może użyć tego klucza do zaszyfrowania wiadomości, ale tylko posiadacz drugiego, tajnego klucza może odszyfrować taką wiadomość.
				
				Kryptografia asymetryczna opiera się na funkcjach jednokierunkowych – takich, które da się łatwo wyliczyć w jedną stronę, ale bardzo trudno w drugą. Np. mnożenie jest łatwe, a rozkład na czynniki (z ang. faktoryzacja) trudny (na czym przykładowo opiera się \textbf{RSA}). Potęgowanie modulo jest łatwe, a logarytmowanie dyskretne jest trudne (na czym opierają się ElGamal, DSA i \textbf{ECC}).
				
				\begin{figure}[h]
					\centering\includegraphics[scale=0.45]{krypt_asym_1.png}
					\caption{Krok 1: Alice przesyła do Boba swój klucz publiczny}
					
					\hspace{5pt}
					
					\centering\includegraphics[scale=0.45]{krypt_asym_2.png}
					\caption{Kroki 2 i 3: Bob szyfruje wiadomość kluczem publicznym Alice, która to następnie otrzymuje zaszyfrowaną wiadomość i rozszyfrowuje ją kluczem prywatnym}
				\end{figure}
				
				Klucz publiczny używany jest do zaszyfrowania informacji, klucz prywatny do jej odczytu. Ponieważ klucz prywatny jest w wyłącznym posiadaniu adresata informacji, tylko on może ją odczytać. Natomiast klucz publiczny jest udostępniony każdemu, kto zechce zaszyfrować wiadomość.
				
				Ponieważ kryptografia asymetryczna jest o wiele wolniejsza od symetrycznej, prawie nigdy nie szyfruje się wiadomości za pomocą kryptosystemów asymetrycznych (również ze względu na ograniczenie wielkości szyfrowanej wiadomości). Zamiast tego szyfruje się jedynie klucz jakiegoś szyfru symetrycznego, takiego jak np. AES. Takie protokoły, łączące elementy kryptografii symetrycznej i asymetrycznej, nazywa się hybrydowymi.
				
				Nadawcy mogą także używać kluczy prywatnych do cyfrowego podpisywania wiadomości. Te podpisy cyfrowe pozwalają odbiorcom uwierzytelnić tożsamość nadawcy i spać spokojnie, wiedząc, że wiadomości nie zostały zmienione od momentu podpisania. W takim przypadku przesyłane informacje mogą być publiczne, a odbiorca może użyć certyfikatu, który towarzyszy tej informacji, aby zweryfikować integralność i autentyczność podpisanej wiadomości.
				
				\begin{figure}[h]
					\centering\includegraphics[scale=0.35]{krypt_asym_podpis.png}
					\caption{Jak działa podpis}
				\end{figure}
				
			\newpage\subsection{\color{red}Bezpieczeństwo sieci w odniesieniu do warstw modelu TCP/IP.}
				a
			\newpage\subsection{\color{red}Metody kontroli dostępu w systemach IT.}
				a
			\newpage\subsection{Atrybuty bezpieczeństwa informacji.}
				Triada bezpieczeczeństwa CIA - Confidentiality, Integrity, Availability
				\begin{enumerate}
					\item Poufność - osoby nieupoważnione nie mają dostępu do informacji podczas
					przechowywania, przetwarzania i przesyłania (np. zaszyfrowanej wiadomości)
					\item Integralność - zapewnia że wiadomość nie została zmodyfikowana (w trakcie
					przechowywania, transportowania lub przetwarzania)
					\item Dostępność - określa nieprzerwany dostęp do zasobów (w odpowiednio szybkim
					czasie) przez osoby aktualnie mające dostęp (np. osoby ze starej sesji nie mają już
					dostępu) i zapobieganie atakom DoS.
					\item Niezaprzeczalność (nie wlicza się do triady) - podmiot nie może zaprzeczyć że
					wykonał jakąś czynność (np. że użytkownik wysłał wiadomość lub chciał uzyskać
					dostęp do strony poprzez logowanie).
					\item Autentyczność - zapewnia że dane które zostały przyjęte pochodzą od osoby która
					faktycznie jest wysłała (jest zapewnione że nikt się nie podszył wysyłając te dane)
					\item Rozliczalność - polega na rejestrowaniu działań/czynności wykonywanych w
					konkretnym czasie przez dane osoby/procesy (np. Janek logował się na strony +18
					30 maja 2018 o 16:54:43)
				\end{enumerate}
	
	\chapter{Pytania - dr. hab. Grzegorz Wójcik}
	
		\section{Bazy danych}
			\subsection{Model relacyjny baz danych i języki zapytań.}
			
				\subsubsection{Model relacyjny baz danych}
				
				Relacyjny model danych pojawił się po raz pierwszy w artykule naukowym Edgara Codda w 1970 roku.
				W terminologii matematycznej - baza danych jest zbiorem relacji.  Stąd historycznie pochodzi nazwa relacyjny model danych i relacyjna baza danych. W matematyce definiuje się relację jako podzbiór iloczynu kartezjańskiego zbiorów wartości. Reprezentacją relacji jest dwuwymiarowa tabela złożona z kolumn i wierszy. \\ \\ Założenia modelu relacyjnego:
				\begin{itemize}
				\itemsep 0em
				\item Liczba \textbf{kolumn/atrybutów/pól (synonimy)} jest z góry ustalona.
				\item Z każdą kolumną jest związana jej nazwa (np. FirstName) oraz dziedzina (np. TEXT(20)), określająca zbiór wartości, jakie mogą wystąpić w kolumnie.
				\item Na przecięciu \textbf{wiersza/krotki/rekordu (synonimy)} i kolumny znajduje się pojedyncza (atomowa) wartość należąca do dziedziny kolumny.
				\item Wiersz reprezentuje jeden rekord informacji np. osobę.
				\item W modelu relacyjnym abstrahujemy od kolejności wierszy (rekordów) i kolumn (pól w rekordzie).
				\end{itemize}
				
				\noindent \textbf{Klucz główny}: dla każdej tabeli musi być określony klucz główny, będący jednoznacznym identyfikatorem. Może to być jedna lub więcej kolumn, w których wartości jednoznacznie identyfikują cały wiersz. Klucz główny w tabeli może być tylko jeden. \\
				\textbf{Klucz jednoznaczny} ma te same właściwości co klucz główny, ale ich może być w tabeli więcej niż jeden. \\
				\textbf{Klucz obcy} - jedna lub więcej kolumn, których wartości występują również jako klucz główny/jednoznaczny w tej samej/innej tabeli i są interpretowane jako wskaźniki do wierszy w tej drugiej tabeli
				
				\noindent \\ \textbf{Dwanaście postulatów Codda} – jest to zestaw 13 zasad stworzonych przez Edgara F. Codda – pioniera relacyjnych baz danych. Każda relacyjna baza danych musi je spełniać:
				\begin{itemize}
				\itemsep 0em
					\item System musi być kwalifikowany jako relacyjny, jako baza danych i jako system zarządzania.
					\item \textbf{Postulat informacyjny} – dane są reprezentowane jedynie przez wartości atrybutów w wierszach tabel (w krotkach).
					\item \textbf{Postulat dostępu} – każda wartość w bazie danych jest dostępna poprzez podanie nazwy tabeli, atrybutu i wartości klucza podstawowego (głównego).
					\item \textbf{Postulat dotyczący wartości NULL} – dostępna jest specjalna wartość NULL dla reprezentacji zarówno wartości nieokreślonej, jak i nieadekwatnej, inna od wszystkich i podlegająca przetwarzaniu.
					\item \textbf{Postulat dotyczący katalogu} – wymaga się, aby system obsługiwał wbudowany katalog relacyjny z bieżącym dostępem dla uprawnionych użytkowników używających języka zapytań.
					\item \textbf{Postulat języka danych} – system musi dostarczać pełny język przetwarzania danych, który może być używany zarówno w trybie interaktywnym, jak i w obrębie programów, obsługuje operacje definiowania danych, operacje manipulowania danymi, ograniczenia związane z bezpieczeństwem i integralnością oraz operacje zarządzania transakcji.
					\item \textbf{Postulat modyfikowalności perspektyw} – system musi umożliwiać modyfikowanie perspektyw, o ile jest ono semantycznie realizowalne.
					\item \textbf{Postulat modyfikowalności danych} – system musi umożliwiać operacje modyfikacji danych, musi obsługiwać operacje INSERT, UPDATE oraz DELETE.
					\item \textbf{Postulat fizycznej niezależności danych} – zmiany fizycznej reprezentacji danych i organizacji dostępu nie wpływają na aplikacje.
					\item \textbf{Postulat logicznej niezależności danych} – zmiany wartości w tabelach nie wpływają na aplikacje.
					\item \textbf{Postulat niezależności więzów spójności} – więzy spójności są definiowane w bazie i nie zależą od aplikacji.
					\item\textbf{ Postulat niezależności dystrybucyjnej} – działanie aplikacji nie zależy od modyfikacji  i dystrybucji bazy.
					\item \textbf{Postulat bezpieczeństwa względem operacji niskiego poziomu} – operacje niskiego poziomu nie mogą naruszać modelu relacyjnego i więzów spójności.
				\end{itemize}
				
			\noindent Operacje modelu relacyjnego:
			\begin{itemize}
				\itemsep 0em
				\item Selekcja - \verb*|WHERE| - selekcja podzbioru wierszy które spełniają określone warunki
				\item Projekcja - \verb*|SELECT| - pominięcie z wyniku pewnych kolumn
				\item Opracje na zbiorach: iloczyn kartezjański - \verb*|FROM| (złączenie tabel), suma zbiorów - \verb*|UNION|, różnica zbiorów - \verb*|EXCEPT|
				\item Agregacja - funkcje agregujące \verb*|SUM|, \verb*|MIN| itd. oraz klauzula \verb*|GROUP BY|
			\end{itemize}
			
			\newpage \subsubsection{Języki zapytań}
			\textbf{SQL} - Structured Query Language - jest to język strukturalny (i deklaratywny) służący do zarządzania bazą danych (CRUD). SQL jest najbardziej znanym językiem zapytań, ale istnieje także xBase.
			
			\begin{itemize}
			\item \textbf{DML (Data Manipulation Language)} służy do wykonywania operacji na danych – do ich umieszczania w bazie, kasowania, przeglądania oraz dokonywania zmian. Najważniejsze polecenia z tego zbioru to:
			\subitem \verb*|INSERT| – umieszczenie danych w bazie,
			\subitem \verb*|UPDATE| – zmiana danych,
			\subitem \verb*|DELETE| – usunięcie danych z bazy.
			
			\item \textbf{DDL (Data Definition Language)} - operacje na strukturach, w których dane są przechowywane – czyli np. dodawanie, zmienianie i kasowanie tabel lub baz. Najważniejsze polecenia tej grupy to:
			
			\subitem \verb*|CREATE| – utworzenie struktury (bazy, tabeli, indeksu itp.)
			\subitem \verb*|DROP| – usunięcie struktury
			\subitem \verb*|ALTER| – zmiana struktury

			\item \textbf{DCL (Data Control Language)} ma zastosowanie do nadawania uprawnień do obiektów bazodanowych. Najważniejsze polecenia w tej grupie to:
			
			\subitem \verb*|GRANT| – nadawanie uprawnień do pojedynczych obiektów lub globalnie konkretnemu użytkownikowi
			\subitem \verb*|REVOKE| – odbieranie wskazanych uprawnień konkretnemu użytkownikowi
			\subitem \verb*|DENY| – zabranianie wykonywania operacji

			\item \textbf{DQL (Data Query Language}) to język formułowania zapytań do bazy danych. W zakres tego języka wchodzi jedno polecenie – \verb*|SELECT|. Często SELECT traktuje się jako część języka DML, ale to podejście nie wydaje się właściwe, ponieważ DML z definicji służy do manipulowania danymi – ich tworzenia, usuwania i uaktualniania. Na pograniczu obu języków znajduje się polecenie SELECT INTO, które dodatkowo modyfikuje (przepisuje, tworzy) dane.
			\end{itemize}
				
				
			\newpage\subsection{Model obiektowo-relacyjny baz danych, inne modele danych.}
			\subsubsection{Model relacyjny}
			W relacyjnym modelu baz danych informacja jest zapisywana w tabeli w formie wierszy. Tabele tworzą między sobą powiązania zwane relacjami. Dużo dużo więcej jest napisane podrozdział wyżej
			
			\subsubsection{Model obiektowy}
			Model obiektowy łączy cechy programów komputerowych tworzonych w językach programowania obiektowego z cechami aplikacji bazodanowych. Obiekt w bazie reprezentuje obiekt w święcie rzeczywistym. Występują tutaj pojęcia klasa, obiekt, dziedziczenie, hermetyzacja. 
			\begin{itemize}
			\itemsep 0em
			\item oprócz danych dostępne są także operacje na danych
			\item użytkownik może definiować własne typy danych
			\item aplikacja oraz BD może być tworzona przy pomocy jednego języka
			\item aplikacja korzystająca z bazy nie wymaga zmiany modelu relacyjnego na obiektowy
			\item nie występuje problem z optymalizacją zapytań
			\item nie występuje ujednolicony standard modelu obiektowego
			\end{itemize}
			
			\subsubsection{Model obiektowo-relacyjny}
			Model ten łączy koncepcję modelu relacyjnego oraz obiektowego. Jego ideą jest połączenie najlepszych cech obydwu modeli.
			\begin{itemize}
				\itemsep 0em
				\item występują tutaj tabele które mogą mieć pola o typie ATD (Abstract Data Type). Umożliwiają one przechowywanie w bazie np. list, kolejek, drzew - obiektów którym możemy przypisać pewne cechy i zachowanie - mają swoje własne implementacje sortowania, wyszukiwania itp
				\item przystosowanie do przechowywania multimediów
				\item ten model zwraca dane jako tabele krotek (jak w bazie relacyjnej), a nie jako kolekcję
				obiektów
				\item programista musi zamienić odpowiedź z bazy danych będącą w postaci krotek (jak w
				relacyjnej) na postać obiektową
			\end{itemize}
			
			\subsubsection{Model hierarchiczny}
			W tym modelu przechowywane dane są zorganizowane w postaci drzewa. Informacja jest zawarta w dokumentach oraz w strukturze drzewa (podobnej do drzewa folderów na dysku komputera).
			\begin{figure}[h]
				\includegraphics[width=10cm]{modelhierarchiczny}
				\centering
			\end{figure}
			\begin{itemize}
				\itemsep 0em
				\item dane są przedstawione w postaci drzewa (najłatwiej to porównać do XML)
				\item informacje są przechowywane w strukturze drzewa
				\item tabele muszą być zawsze ze sobą powiązane, czyli podrzędne z nadrzędnym (np.
				uczeń musi być podpięty pod jakąś szkołę)
				\item usunięcie tabeli nadrzędnej powoduje usunięcie wszystkich tabel podrzędnych
			\end{itemize}
			\subsubsection{Model sieciowy}
			Połączenia między dokumentami tworzą sieć. Informacja jest zawarta w dokumentach oraz w przebiegu połączeń sieci.
			\begin{figure}[h]
				\includegraphics[width=10cm]{modelsieciowy}
				\centering
			\end{figure}
			\begin{itemize}
				\itemsep 0em
				\item jest to rozwinięcie modelu hierarchicznego gdzie tabele podrzędne mają wiele tabel
				nadrzędnych (skutkiem czego jest stworzenie grafu/sieci)
				\item można bezpośrednio odczytywać każdą tabele (nie trzeba przechodzić od korzenia
				do liścia jak w hierarchicznym)
				\item relacje/zależności między tabelami są nazywane strukturami
				\item w strukturze można wyłonić jedną tabelę główną z której to można przejść do tabel
				podrzędnych
				\item struktura jest relacja 1:N
				\item zmiany w bazie są bardzo trudne do wykonania
			\end{itemize}
			\subsubsection{Model semistrukturalny}
			\begin{itemize}
				\itemsep 0em
				\item polega na przedstawieniu danych w postaci modelu XML		
				\item przedstawia on dane w postaci drzewiastej (czyli jest hierarchiczny)
				\item zapytania są w postaci ścieżki
				\item atrybuty znacznika przechowywują dodatkowe informacje (cechy)
				\item dane w postaci XML można łatwo umieścić na stronie WWW (tylko trzeba określić sposób wyświetlania)
				\item baza w postaci /xML może być łatwo przekonwertowana na obiekt
			\end{itemize}
			
			\subsubsection{Model jednorodny}
			Wszystkie dane upchane w jednej tabeli, łatwo szukać danych po unikalnej wartości (ale ciężej po czymś nieunikalnym np nazwisko), taka forma posiada dużo duplikatów
				
			\newpage\subsection{Składnia podstawowych zapytań języka SQL.}
				\subsubsection{DDL - Data Definition Language}
				\noindent Jak zapamiętać skrót: \\ Definition = DEFINIOWANIE - TWORZENIE STRUKTUR \\
				\noindent W skład DDL wchodzą \verb*|DROP|, \verb*|CREATE| oraz \verb*|ALTER|.
				\begin{itemize}
					\itemsep 0em
					\item \verb*|DROP| - usunięcie struktury
					\begin{verbatim}
						DROP TABLE tabela;
					\end{verbatim}
					\item \verb*|CREATE| - stworzenie struktury
					\begin{verbatim}
						CREATE TABLE tabela(
							kolumna1 typ (rozmiar),
							kolumna2 typ (rozmiar),
							...
						);
					\end{verbatim}
					\item \verb*|ALTER| - modyfikacja struktury. Obejmuje operacje takie jak np. dodanie kolumny do tabeli, zmiana typu danych w kolumnie, usunięcie kolumny.
					\begin{verbatim}
						ALTER TABLE table
						ADD kolumna typ(dlugosc);
					\end{verbatim}
					\begin{verbatim}
						
					\end{verbatim}
				\end{itemize}
				
				
				\subsubsection{DML - Data Manipulation Language}
				\noindent Jak zapamiętać skrót: \\ Manipulation = MANIPULACJA - EDYCJA LUB TWORZENIE REKORDÓW \\
				\noindent W skład DML wchodzą \verb*|INSERT|, \verb*|UPDATE| oraz \verb*|DELETE|.
				\begin{itemize}
					\itemsep 0em
					\item \verb*|INSERT| - dodawanie wierszy
					\begin{verbatim}
						INSERT INTO tabela (kolumna1, kolumna2, ..., kolumna_n)
						VALUES (wartosc1, wartosc2, ..., wartosc_n)
					\end{verbatim}
					Nie trzeba podawać kolumn po nazwie tabeli gdy podamy po pierwsze wszystkie wartości, a po drugie w dobrej kolejności
					
					\item \verb*|UPDATE| - aktualizowanie danych, zmiana
					\begin{verbatim}
						UPDATE tabela
						SET kolumna1 = wartosc, kolumna2 = wartosc2, ...
						WHERE warunek
					\end{verbatim}
					WHERE nie jest konieczny, możemy  go użyć jak chcemy doprecyzować które rekordy mają się zaktualizować
					
					\item \verb*|DELETE| - usuwanie wierszy
					\begin{verbatim}
						DELETE FROM tabela
						WHERE warunek
					\end{verbatim}
					WHERE nie jest konieczny, możemy  go użyć jak chcemy doprecyzować które rekordy mają się skasować
				\end{itemize}
				\subsubsection{DCL - Data Control Language}
				\noindent Jak zapamiętać skrót: \\ Control = KONTROLA = UPRAWNIENIA \\
				\noindent W skład DCL wchodzą \verb*|GRANT|, \verb*|REVOKE| oraz \verb*|DENY|.
				
				\begin{itemize}
					\item \verb*|GRANT| - nadawanie uprawnień do pojedynczych obiektów lub globalnie konkretnemu userowi
					\item \verb*|REVOKE| - odbieranie uprawnień konkretnemu userowi
					\item \verb*|DENY| - zabranianie wykonywania operacji
					\item Składnia jest taka sama dla w/w poleceń:
					\begin{verbatim}
						[GRANT/REVOKE/DENY] operacja1, operacja2, ...
						ON tabela
						TO user
					\end{verbatim}
					Przykład:
					\begin{verbatim}
					GRANT SELECT, INSERT
					ON Fragment
					TO glazik
					\end{verbatim}
				\end{itemize}
				
				\subsubsection{DQL - Data Query Language}
				\noindent Jak zapamiętać skrót: \\ Query = ZAPYTANIA = SELECTY \\
				\noindent W skład DQL wchodzi jedno polecenie: \verb*|SELECT|. Pozwala wybierać wiersze z bazy danych. Składnia:
				\begin{verbatim}
					SELECT kolumny 
					FROM tabele 
					WHERE warunek
					GROUP BY kolumna
					HAVING warunek
					ORDER BY ... DESC/ASC;
				\end{verbatim}
				Dodatkowe klauzule \verb*|SELECT|:
				\begin{itemize}
					\itemsep 0em
					\item \verb*|ORDER BY| - sortowanie wyników względem np. kolumny
					\item \verb*|ASC| oraz \verb*|DESC| - dodawane po sortowaniu, wybieramy czy ma być ascending czy descending
					\item \verb*|GROUP BY| - grupowanie wyników względem danej kolumny
					\item \verb*|HAVING| - filtrowanie grup, działa podobnie do WHERE. WHERE oraz HAVING mogą występować jednocześnie w zapytaniu.
				\end{itemize}
				
			\newpage\subsection{Projektowanie baz danych oraz model związków encji.}
			\subsubsection{Projektowanie baz danych}
				Etapy projektowania systemów bazodanowych:
				\begin{itemize}
					\item \textbf{Sformułowanie problemu}
					\item \textbf{Analiza wycinka rzeczywistości} - wywiad z ekspertem dziedzinowym, analiza wymagań funkcjonalnych (co dodawać, co usuwać itd.) i niefunkcjonalnych (tryb graficzny, platforma sprzętowa itd.)
					\item \textbf{Opracowanie konceptualnego modelu danych}, czyli wyodrębnienie i zdefiniowanie encji, związków między nimi oraz atrybutów (taka jakby luźna forma) \\
					Projektowanie modelu konceptualnego bazy danych składa się z następujących etapów:
					\begin{itemize}
						\item \textbf{określenie zbiorów encji} - jakie encje (tabele) będzie zawierać baza?
						\item \textbf{określenie atrybutów encji} - jakie cechy (kolumny) będą miały poszczególne encje?
						\item \textbf{określenie dziedziny atrybutów} - jaki zakres wartości będzie miał każdy atrybut?
						\item \textbf{ustalenie kluczy podstawowych} - a'la klucze główne (?)
						\item \textbf{określenie związków między encjami} - a'la klucze obce (?)
					\end{itemize}
					\textbf{Encja} to każdy element rzeczywistości, który można scharakteryzować i odróżnić od innych obiektów, np. książka (przedmiot), klient (obiekt), zamówienie (zjawisko), stan cywilny (stan). \\
					\textbf{Atrybut} to cecha encji. Zestaw atrybutów, które określamy dla encji, zależy od potrzeb bazy danych (np. książka ma atrybuty: tytuł, autor, ...) \\
					\textbf{Dziedzina} opisuje jakie wartości może przyjąć dany atrybut, np. tytuł książki to napis o długości do x znaków.
					\item \textbf{Opracowanie modelu logicznego}, czyli wyrażenie świata rzeczywistego za pomocą reguł modelu danych (np. relacyjnego). Transformujemy model konceptualny do logicznego. Zamiast encji są tabele, zamiast związków są wiązania poprzez klucze główne i obce itd. Następuje normalizacja relacji.
					\item \textbf{Opracowanie modelu fizycznego}, czyli konstruowanie modelu świata rzeczywistego za pomocą struktur danych i mechanizmów istniejących w wybranym SZBD (systemie zarządzania bazami danych), czyli np naklepanie tego w MySQL
					\item \textbf{Tworzenie aplikacji}
					\item \textbf{Testowanie systemu}
				\end{itemize}
				
			\newpage
			\subsubsection{Model związków encji}
			\noindent  Model związków encji (model ER lub ERD) to jedna z najpopularniejszych metod modelowania danych. Służy do graficznego przedstawiania koncepcji projektowanej bazy danych. Jest bardzo podobny do relacyjnego modelu. Diagram taki pokazuje obiekty (encje), ich cechy (atrybuty) oraz relacje między nimi. Elementy takie, jak encja, atrybut oraz związek zostały opisane stronę wyżej. \\ \\
			Typy związków encji:
			\begin{itemize}
				\itemsep 0em
				\item \textbf{jeden do jednego} (1:1) \\
				Związek ten określa, iż każde wystąpienie danego obiektu (encji) związane jest wyłącznie z pojedynczym wystąpieniem innego bytu. Na przykład: Pracownik w organizacji ma przypisane konkretne Miejsce, a to Miejsce jest przypisane do konkretnego Pracownika. Kierownik zarządza jednym Działem, a Dział zarządzany jest przez jednego Kierownika.
				\item \textbf{jeden do wielu} (1:N) \\
				Związek ten określa, iż jedno wystąpienie danego obiektu (encji) związane jest z większą ilością wystąpień innego bytu. Na przykład: Klient składa wiele Zamówień. Konkretne Zamówienie jest składane przez danego Klienta. W Firmie istnieje wiele Działów. Konkretny Dział istnieje w danej Firmie.
				\item \textbf{wiele do wielu} (M:N) \\
				Związek ten określa, iż jedno wystąpienie danego obiektu (encji) związane jest z większą ilością wystąpień innego bytu, tak samo jak jedno wystąpienie innego bytu może być powiązane z większą ilością wystąpień tego pierwszego obiektu. Przykładem takiego związku może być zależność jaka występuje pomiędzy Studentem oraz Wykładem. Student zapisany może być na wiele Wykładów, tak i na dany Wykład zapisanych może być wielu Studentów.
			\end{itemize}
			
			\newpage\subsection{Problemy indeksowania baz danych, rodzaje indeksów, indeksy typu B+ drzewo.}
				\subsubsection{Problemy indeksowania baz danych}
				Problem z przeszukiwaniem baz danych polega na tym, że… tabele w MySQL (a także w innych RDBMS) \textbf{nie są posortowane według kolumn}, dzięki którym wyciągamy odpowiednie dane. Dane ulegają aktualizacji, usuwaniu i ciągle dodawane są nowe. Jedyna „kolejność” to często klucz główny, który jest de facto indeksem. Nie jest to przydatna kolejność kiedy szukamy danych nie po kluczu a po jakimś innym polu np:
					\begin{verbatim}
						SELECT nazwa_produktu FROM produkty WHERE cena = 128; 
					\end{verbatim}
				Jeżeli mielibyśmy te nasze produkty posortowane według ceny, to znalezienie było by banalne. W przypadku kiedy dane są posortowane po kluczu głównym trzeba „sprawdzić” wszystkie rekordy i nie mamy możliwości ułatwienia sobie zadania bo produkty mogą mieć przecież różną cenę. Mówi wtedy że dokonujemy \textbf{pełnego skanu tabeli} (ang. full table scan), który działa niekorzystnie na wydajność – zabiera po prostu za wiele czasu. Sztuka optymalizacji za pomocą indeksowania polega na unikaniu tego pełnego skanu. Działanie indeksu polega na tym, że zawiera w przystępnej postaci informację, w których komórkach pamięci znajdują się produkty o cenie 128. Z tego korzysta RDBMS – najpierw uderza do indeksu a kiedy już wie skąd ma pobrać dane to od razu przechodzi do odpowiednich miejsc bez przeszukiwania całej tabeli i zwraca wynik użytkownikowi. \\
				
				\noindent \textbf{Zalety indeksów:} znacznie przyspieszają pewne SELECTy \\
				\textbf{Wady selectów:} spowalniają dodawanie, modyfikowanie i usuwanie danych (w przypadku edycji tabeli należy również zaktualizować jej indeks)
				
				\subsubsection{Rodzaje indeksów}
				\begin{itemize}
					\item \textbf{Ze względu na liczbę wskazań indeksu (ile rekordów wskazuje indeks)}:
						\subitem \textit{indeks rzadki} - zawiera rekordy tylko dla wybranych rekordów indeksowanego pliku (indeksowana jest tylko część pliku)
						\subitem \textit{indeks gęsty} - zawiera rekord indeksu dla każdego rekordu indeksowanego pliku (indeksowany jest cały plik)
					\item \textbf{Ze względu na liczbę poziomów indeksu (indeks może wskazywać na inny indeks)}:
						\subitem \textit{indeks jednopoziomowy} - do pliku z danymi tworzony jest tylko jeden indeks na dany atrybut
						\subitem \textit{indeks wielopoziomowy} - do pliku z danymi tworzonych jest wiele indeksów na dany atrybut (tworzenie indeksu do indeksu)
					\item \textbf{Ze względu na charakterystykę indeksowanego atrybutu}:
						\subitem \textit{indeks podstawowy} - - jest on założony na atrybucie (unikalnym) który umożliwia porządkowanie pliku (np. klucz główny, PESEL, dane osobowe). Jest to indeks rzadki.
						\subitem \textit{indeks zgrupowany} - jest on zakładany na atrybucie który nie jest unikalny (również umożliwia porządkowanie pliku) (np. imię, wartość liczbowa). Ten indeks wskazuje na pierwszy blok w którym występuje dana wartość (patrz wartość 2, 3, 4). Jest to indeks rzadki.
						\subitem \textit{indeks wtórny} - jest on zakładany na atrybucie który nie jest atrybutem uporządkowanym (czyli taki według którego plik nie jest uporządkowany). Jest to indeks gęsty.
					\item \textbf{Ze względu na liczbę indeksowanych atrybutów}
						\subitem \textit{indeks z kluczem prostym} - indeksowany jest tylko jeden atrybut/klucz
						\subitem \textit{indeks z kluczem złożonym} - indeksowane jest wiele atrybutów jednocześnie (klucz)
					\item \textbf{Ze względu na zarządzanie strukturą}
						\subitem \textit{indeksowanie statyczne} - indeks nie ma mechanizmów które modyfikują strukturę czyli np. usuwanie pozostawia puste rekordy w indeksie, a dodawanie polega na dodawaniu rekordów do specjalnego miejsca zwanego “blokiem przepełnienia”
						\subitem \textit{indeksowanie dynamiczne} - indeks ma mechanizmy które modyfikują strukturę (i nie ma tych problemów co w indeksowaniu statycznym)
				\end{itemize}
				\subsubsection{Indeksy typu B+ drzewo}
				\begin{itemize}
				\itemsep 0em
				\item to rodzaj indeksowania dynamicznego wielowarstwowego które jest przedstawione w postaci drzewa
				\item każdy indeks posiada wskaźnik (który nie jest liściem) wskazuje na inny indeks
				\item wskaźnik po lewej stronie klucza (wartości atrybutu) zawiera wartości mniejsze, a po prawej większe
				\item węzły tego drzewa mogą pomieścić określona ilość rekordów indeksu
				\item gdy rekordów w węźle jest za dużo to następuje dzielenie węzła, a gdy w dwóch węzłach jest mniej niż połowa to następuje łączenie węzłów
				\item B+ drzewo rośnie do góry (tak samo jak B)
				\item jest to drzewo zrównoważone (odległość od korzenia do liścia wszędzie jest taka sama)
				\item węzły które nie są liśćmi nie posiadają wartości (w B-drzewie posiadały)
				\item wartości kluczy które są w węzłach wewnętrznych powtarzają się w liściach (np. (2,4) C (1,2,3,4,5)
				\item liście są ze sobą połączone (liść o mniejszych wartościach ma wskaźnik do liścia o większych wartościach)
				\item Wyszukiwanie informacji w drzewie wynosi O(logn)
				\end{itemize}

			\newpage\subsection{Przetwarzanie transakcyjne OLTP (On-Line Transaction Processing).}
		\textbf{OLTP} (Online Transaction Processing) to kategoria aplikacji klient-serwer dotyczących baz danych w ramach bieżącego przetwarzania transakcji obejmujących takie zastosowania jak systemy rezerwacji, obsługa punktów sprzedaży, systemy śledzące itp. W systemach tych klient współpracuje z serwerem transakcji, zamiast z serwerem bazy danych.  Zastosowanie - np. w bankowości internetowej, w handlu detalicznym, podczas składania zamówień lub przy wysyłaniu wiadomości tekstowych. Transakcje te (tradycyjnie określane jako transakcje gospodarcze lub finansowe) są rejestrowane i zabezpieczane w taki sposób, aby przedsiębiorstwo mogło w każdej chwili uzyskać do nich dostęp w celach księgowych lub sprawozdawczych. \\

		System OLTP:
		\begin{itemize}
			\itemsep 0em
			\item Umożliwia wykonywanie w czasie rzeczywistym dużej liczby transakcji bazodanowych przez dużą liczbę osób
			\item Wymaga błyskawicznych czasów reakcji
			\item Często modyfikuje małe ilości danych i zazwyczaj dokonuje tyle samo odczytów, co zapisów danych
			\item Używa indeksowanych danych w celu skrócenia czasu odpowiedzi
			\item Wymaga częstego lub równoczesnego wykonywania kopii zapasowych bazy danych
			\item Wymaga stosunkowo niewiele miejsca do przechowywania danych
			\item Zazwyczaj obsługuje proste zapytania dotyczące tylko jednego lub kilku rekordów
		\end{itemize}
		
		\textbf{Transakcja} to zbiór operacji na bazie danych, które stanowią w istocie pewną całość i powinny być wykonane wszystkie lub żadna z nich. Składa się zawsze z trzech etapów: \textbf{rozpoczęcia, wykonania i zamknięcia}. W systemach bazodanowych istotne jest, aby trwała jak najkrócej, ponieważ równolegle może być wykonywane wiele transakcji i część operacji musi zostać wykonana w pewnej kolejności. Każdy etap transakcji jest logowany, dzięki czemu w razie awarii można odtworzyć stan bazy sprzed transakcji. \\
		Cechy transakcji: \textbf{ACID} \\
		- \textbf{A}tomicity - atomowość - wykona się wszystko albo nic (zbiór operacji = całość); \\
		- \textbf{C}onsistency - spójność - baza przed i po zmianach jest spójna; \\
		- \textbf{I}solation - izolacja - równolegle wykonywane transakcje nie mają na siebie wpływu; \\
		- \textbf{D}urability - trwałość - zmiany prowadzone przez transakcje są trwałe (nawet w przypadku awarii);\\
		W SQL wyróżniamy następujące polecenia dotyczące transakcji:
		\begin{itemize}
			\itemsep 0em
			\item \verb*|BEGIN| lub \verb*|BEGIN WORK| – rozpoczęcie transakcji
			\item \verb*|COMMIT| – zatwierdzenie zmian wykonanych w obrębie transakcji
			\item \verb*|ROLLBACK| – odrzucenie zmian wykonanych w obrębie transakcji
			\item \verb*|SAVEPOINT nazwa| – zdefiniowanie punktu pośredniego o określonej nazwie
			\item \verb*|RELEASE SAVEPOINT nazwa| – skasowanie punktu pośredniego (nie wpływa w żaden sposób na stan transakcji)
			\item \verb*|ROLLBACK TO SAVEPOINT nazwa| – wycofanie transakcji do stanu zapamiętanego w podanym punkcie pośrednim.
		\end{itemize}
		\newpage\section{Paradygmaty}
			\subsection{Założenia paradygmatu programowania obiektowego.}
				Paradygmat obiektowy zakłada modułowość, czyli tworzenie programu z wcześniej
				zdefiniowanych komponentów (np. klasy).
				
				Główne założenia paradygmatu programowania obiektowego:
				\begin{enumerate}
					\item \textbf{Abstrakcja} - to przedstawienie obiektu ze świata rzeczywistego i jego cech jako
					uproszczony model/szablon (tutaj klasa i obiekty) wykorzystywany w problemie
					programistycznym.
					\item \textbf{Hermetyzacja (enkapsulacja)} - to ukrycie implementacji przed użytkownikiem
					(prywatne pola - publiczne metody).
					Cytując kogoś mądrego: “Hermetyzacja polega na tym, że klasy są zamkniętymi
					"czarnymi skrzynkami" - inne klasy nie muszą wiedzieć dokładnie co się dzieje w
					środku, mogą wchodzić z nimi w interakcje poprzez elementy, które wystawiają
					publicznie (publiczne pola i metody)”.
					\item \textbf{Dziedziczenie} - jest to tworzenie hierarchii klas. Klasa dziedzicząca otrzymuje pola i
					metody (te może zmieniać) “klasy matki”. Tworzenie bardziej wyspecjalizowanego
					obiektu z bardziej ogólnego. (np. klasa jabłko dziedziczy cechy po klasie owoc)
					\item \textbf{Polimorfizm} - polega na dostosowaniu zachowania obiektów do oczekiwań
					użytkownika. Inaczej mówiąc gdy grupa obiektów dziedziczy metodę od innej klasy.
					Każda klasa która odziedziczyła tę metodę to ją zmieniła. Wywołanie tej
					odziedziczonej metody na poszczególnych obiektach wywoła wykonanie instrukcji
					zaimplementowanych dla każdego obiektu. (np. dla każdej figury funkcja obliczania
					pola będzie inna)
				\end{enumerate}
			\newpage\subsection{Idea dziedziczenia i polimorfizmu w programowaniu.}
				\subparagraph{Dziedziczenie} - jest to tworzenie hierarchii klas. Klasa dziedzicząca otrzymuje pola i metody
				(te może zmieniać) “klasy matki”. Tworzenie bardziej wyspecjalizowanego obiektu z bardziej
				ogólnego. (np. klasa jabłko dziedziczy cechy po klasie owoc).
				Umożliwia ona większą czytelność kodu który jednocześnie staje się prostszy (bo po co
				pisać 2 razy to samo)
				
				\subparagraph{Polimorfizm} - polega na dostosowaniu zachowania obiektów do oczekiwań użytkownika.
				Inaczej mówiąc gdy grupa obiektów dziedziczy metodę od innej klasy. Każda klasa która
				odziedziczyła tę metodę to ją zmieniła. Wywołanie tej odziedziczonej metody na
				poszczególnych obiektach wywoła wykonanie instrukcji zaimplementowanych dla każdego
				obiektu. (np. dla każdej figury funkcja obliczania pola będzie inna)
				
				Polimorfizm umożliwia nie tylko wykonywanie odpowiednio metod dla obiektów pochodnych
				ale również przypisanie do bardziej ogólnego typu danych (np. Owoc jablko= new Jablko(); )
			\newpage\subsection{Zasady programowania dynamicznego.}
				\subparagraph{Programowanie dynamiczne} - jest to rozszerzenie strategii "dziel i zwyciężaj". „Programowanie” oznacza w tym
				kontekście tabelaryczną metodę rozwiązywania problemów, a nie pisanie programów komputerowych. Wiemy, że w algorytmach typu „dziel i zwyciężaj” dzieli się problem na niezależne podproblemy, rozwiązuje je rekurencyjnie, a następnie łączy się rozwiązania
				wszystkich podproblemów w celu utworzenia rozwiązania pierwotnego problemu. Programowanie dynamiczne można stosować wtedy, kiedy podproblemy nie są niezależne, tzn. kiedy podproblemy mogą zawierać te same podpodproblemy. Wtedy algorytm typu „dziel i zwyciężaj” wykonuje więcej pracy niż to w istocie jest konieczne, wielokrotnie
				bowiem rozwiązuje ten sam podproblem. \\
				
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.45]{problem_dynam.png}
					\caption{Przykładowy problem złożony}
				\end{figure}
				
				Jak widać na obrazku wyżej chcąc obliczyć rozwiązania problemów P1 i P2 rozwiązaniem typu "dziel i zwyciężaj", problem P4 zostałby policzony 2 razy jako problem zależny. Programowanie dynamiczne ma na celu optymalizację takich przypadków i pisząc program zapamiętalibyśmy rozwiązanie P4 gdy liczymy P1. Nastepnie obliczając drugi głowny problem - P2, znamy już rozwiązanie P4 więc nie marnujemy czasu i mocy obliczeniowej.\\
				
				\textbf{Proces projektowania algorytmu} opartego na programowaniu dynamicznym można podzielić na cztery etapy: 
				\begin{enumerate}
					\item Scharakteryzowanie struktury optymalnego rozwiązania. 
					\item Rekurencyjne zdefiniowanie kosztu optymalnego rozwiązania.
					\item Obliczenie optymalnego kosztu metodą wstępującą (ang. bottom-up) – czyli rozpoczynając od najmniejszych podproblemów, rozwiązywać coraz większe, wykorzystując zapamiętane rozwiązania mniejszych.
					\item Konstruowanie optymalnego rozwiązania na podstawie wyników wcześniejszych obliczeń. 
				\end{enumerate}
				
				\textbf{Zasady} paradygmatu programowania dynamicznego (pretty much to samo co proces projektowania) to:
				\begin{itemize}
					\item Scharakteryzować strukturę rozwiązania optymalnego.
					\item Zdefiniować rekurencyjnie wartość rozwiązania optymalnego, jako funkcję rozwiązań optymalnych dla podproblemów.
					\item Skonstruować optymalne rozwiązanie problemu na bazie wyliczonych wcześniej wielkości.
				\end{itemize}
			
			\newpage\subsection{Główne paradygmaty programowania.}
				\subparagraph{Paradygmat programowania} - jest to wzorzec sposobu programowania, patrzenia na dane,
				przepływ danych oraz sposób wykonywania programu.
				
				\subsubsection{Programowanie imperatywne}
				Chcąc najkrócej scharakteryzować programowanie imperatywne, moglibyśmy napisać „zrób najpierw to, a potem tamto”. Mamy zatem sekwencję poleceń zmieniających krok po kroku stan maszyny, aż do uzyskania oczekiwanego wyniku — czyli mamy stan będący funkcją czasu. Ten sposób patrzenia na programy związany jest ściśle z budową sprzętu komputerowego o architekturze von Neumanna, w którym poszczególne instrukcje to właśnie polecenia zmieniające ów globalny stan.
				
				Imperatywne języki programowania posługują się abstrakcjami bliskimi architekturze von Neumanna, np. zmienne są abstrakcją komórek pamięci. Naturalną abstrakcją są tu też procedury (będące, notabene, zasadniczym elementem „podparadygmatu” proceduralnego). Najważniejsze — w swoim czasie — języki imperatywne to Fortran, Cobol, Pascal i C.
				
				\subsubsection{Programowanie proceduralne}
				Programowanie proceduralne – paradygmat programowania zalecający dzielenie kodu na procedury, czyli fragmenty wykonujące ściśle określone operacje. Procedury nie powinny korzystać ze zmiennych globalnych (w miarę możliwości), lecz pobierać i przekazywać wszystkie dane (czy też wskaźniki do nich) jako parametry wywołania.
				
				\subsubsection{Programowanie strukturalne}
				O programowaniu strukturalnym wspominamy z kronikarskiego obowiązku, jest to bowiem bardzo dobrze znany i powszechnie stosowany „podparadygmat” programowania imperatywnego, czy ściślej — proceduralnego. Chodzi w nim o tworzenie programów z kilku dobrze zdefiniowanych konstrukcji takich jak instrukcja warunkowa if-then-else i pętla while, za to bez skoków (go to). Powinno to sprzyjać pisaniu programów przejrzystych, łatwych w rozumieniu i utrzymaniu.
				
				Ściślej, Dijkstra proponował użycie tylko trzech rodzajów struktur sterujących:
				\begin{itemize}
					\item Sekwencja (lub konkatenacja) — czyli po prostu wykonanie instrukcji w określonej kolejności. W wielu językach rolę „operatora konkatenacji instrukcji” spełnia niepozorny średnik...
					\item Wybór — czyli wykonanie jednej z kilku instrukcji zależnie od stanu programu. Przykładem jest if-then-else i switch/case.
					\item Iteracja, czyli powtarzanie instrukcji tak długo, jak długo spełniony (lub niespełniony) jest dany warunek. Chodzi oczywiście o pętle, np. while, repeat-until, for itp.
				\end{itemize}
			
			
				\subsubsection{Programowanie obiektowe}
				W programowaniu obiektowym program to zbiór porozumiewających się ze sobą obiektów, czyli jednostek zawierających określone dane i umiejących wykonywać na nich określone operacje. Najważniejsze są tu dwie cechy: po pierwsze, powiązanie danych (czyli stanu) z operacjami na nich (czyli poleceniami) w całość, stanowiącą odrębną jednostkę — obiekt; po drugie, mechanizm dziedziczenia, czyli możliwość definiowania nowych, bardziej złożonych obiektów, na bazie obiektów już istniejących.
				
				Z tych dwóch cech bierze się zapewne wielki sukces paradygmatu obiektowego. Umożliwia on bowiem modelowanie zjawisk rzeczywistego świata w uporządkowany, hierarchiczny sposób — od idei do szczegółów technicznych. Wśród najważniejszych języków należy wymienić C++ (chociaż nie jest to język czysto obiektowy) i Javę; ze względów historycznych i poznawczych należałoby dodać Simulę 67 i Smalltalk.
				\subsubsection{Programowanie funkcyjne}
				Tu po prostu składamy i obliczamy funkcje, w sensie podobnym do funkcji znanych z matematyki. Nie ma stanu maszyny — nie ma zmiennych mogących zmieniać wartość. Nie ma zatem „samodzielnie biegnącego” czasu, a jedynie zależności między danymi. Nie ma efektów ubocznych. Można by wręcz sądzić, że programowanie funkcyjne zdefiniowane zostało jako poważne ograniczenie paradygmatu imperatywnego... Rzeczywiście, do pewnego stopnia zwykłe języki imperatywne zawierają w sobie „podjęzyk” funkcyjny (można przecież tworzyć, składać i wywoływać funkcje). Prawdziwe języki funkcyjne oferują jednak znacznie więcej, m.in. rekurencyjne struktury danych i możliwość operowania funkcjami wyższego rzędu.
				
				Programowanie funkcyjne nie doczekało się takiej popularności jak dwa poprzednie paradygmaty, choć są dziedziny, gdzie jego pozycja jest przyzwoita (np. język Erlang używany w telekomunikacji oraz język K używany do obliczeń finansowych). Najsłynniejsze języki funkcyjne żyły lub żyją przede wszystkim w środowiskach akademickich: Lisp, Scheme (potomek Lispu), ML, Ocaml (potomek ML-a), Miranda, Haskell.
				\subsubsection{Programowanie w logice}
				Podobnie jak w programowaniu funkcyjnym, nie „wydajemy rozkazów”, a jedynie opisujemy, co wiemy i co chcemy uzyskać (z tego powodu języki funkcyjne i logiczne nazywa się łącznie językami deklaratywnymi). Na program składa się zbiór zależności (przesłanki) i pewne stwierdzenie (cel). Wykonanie programu to próba udowodnienia celu w oparciu o podane przesłanki, a więc pewien rodzaj automatycznego wnioskowania; obliczenia wykonywane są niejako „przy okazji” dowodzenia celu.
				
				Język programowania w logice (a ściślej — jego interpreter) to właściwie system automatycznego dowodzenia twierdzeń, działający w oparciu o nieco uproszczony rachunek predykatów. Kluczowym pojęciem jest tu rezolucja, realizowana m.in. przy pomocy unifikacji i nawrotów. Zastosowania programowania w logice obejmują przede wszystkim sztuczną inteligencję (np. systemy ekspertowe, rozpoznawanie obrazów) i przetwarzanie języka naturalnego. Językiem, który uzyskał największą popularność, jest Prolog. Historycznie ważny jest również Planner — wcześniejszy i bardziej złożony od Prologu.
				

			\newpage\subsection{Cechy programowania deklaratywnego.}
				W programowaniu deklaratywnym programista deklaruje mając jakiś element co chce z
				niego uzyskać (nie jest mówione jak to ma zostać wykonane, tylko jest mówione jaki ma być
				efekt).
				
				Cechy:
				\begin{itemize}
					\item wzorowany na językach naturalnych
					\item nieliniowe wykonanie (komenda końcowa może modyfikować początek)
					\item bardzo częste wykonywanie rekurencji zamiast pętli
					\item definiuje problem i szuka odpowiedź na zadane pytanie
				\end{itemize}
			
				Do programowania deklaratywnego zalicza się:
				\begin{itemize}
					\item języki funkcyjne - zamiast instrukcji używa się funkcji (cały program to funkcja).
					Przykładem jest Haskell w którym Wszystko opiera się na wyrażeniach Lambda. W
					tym języku funkcje są sobie równe jeśli dają takie same odpowiedzi.
					\item języki w logice - zamiast instrukcji używa się zdań logicznych. np. w Prologu zdania
					logiczne na początku opisują zależności (między elementami) aby na końcu zapytać
					czy podane zdanie jest prawdziwe (oczywiście trzeba na koniec podać to zdanie).
					Tutaj wszystko jest wyrażeniem logicznym
				\end{itemize}
	
	\chapter{Pytania - reszta}
	
		\section{Jezyk C i C++}
			\subsection{Instrukcje sterujące w języku C.}
				\subparagraph{Instrukcja sterująca}jest to każda instrukcja, która może zmienić kolejność wykonywania linii w programie (np.  \verb*|if| czy  \verb*|for|). Dzięki nim program nie jest odczytywany jak tekst od góry do dołu, a może zawierać rozgałęzienia, powtórzenia operacji lub przedwczesne zakończenie.\\
				
				\begin{itemize}
					\item \verb*|IF| - instrukcja warunkowa
					\begin{lstlisting}[language=C]
int a = 4;  
int b = 6;

if (a==b) { 
    printf ("a == b\n"); 
} else { 
    printf ("a != b\n"); 
} 
					\end{lstlisting}
					\item \verb*|SWITCH| - instrukcja warunkowa (warto zwrócić uwagę, że bez \verb*|BREAK|, program będzie sprawdzał kolejne warunki \verb*|CASE|, co może być niepożądanym zachowaniem)
					\begin{lstlisting}[language=C]
unsigned int dzieci = 3, podatek=1000; 
switch (dzieci) { 
    case 0: break; /* brak dzieci - czyli brak ulgi */ 
    case 1: /* ulga 2% */ 
    podatek = podatek - (podatek/100 * 2); 
        break; 
    case 2: /* ulga 5% */ 
        podatek = podatek - (podatek/100 * 5); 
        break; 
    default: /* ulga 10% */ 
        podatek = podatek - (podatek/100 * 10); 
        break; 
} 
					\end{lstlisting}
					\item \verb*|FOR| - instrukcja petli
					\begin{lstlisting}[language=C]
for (int a=1; a<=10; ++a) { 
    printf ("%d\n", a*a); 
}
					\end{lstlisting}
					\item \verb*|WHILE| - instrukcja petli
					\begin{lstlisting}[language=C]
while (a <= 10) {
    printf ("%d\n", a*a);
    ++a;
} 
					\end{lstlisting}
					\item \verb*|DO WHILE| - instrukcja pętli, różni się tym od while że pierwsze wykonanie jest bezwarunkowe, dzięki temu kod pętli wykona się co najmniej jeden raz
					\begin{lstlisting}[language=C]
do { 
    printf ("%d\n", a*a*a); 
    ++a; 
} while (a <= 10);
					\end{lstlisting}
				\item \verb*|BREAK| - przerywa wykonanie pętli, w której się znajduje. W przypadku zagnieżdżonych pętli, przerwana jest tylko "najniższa" petla w hierarchii
				\begin{lstlisting}[language=C]
for (int i = 0; ;++i) { /* pomimo braku warunku zakonczenia
                           BREAK zapewnia, 
                           ze petla jest skonczona */
    if (i == 5) break; 
} 
				\end{lstlisting}
			\item \verb*|CONTINUE| - przechodzi do kolejnej iteracji pętli pomijając pozostałe instrukcje dla bieżącej iteracji
			\begin{lstlisting}[language=C]
for (i = 1 ; i <= 50 ; ++i) { 
    if (i%4==0) continue ; /* zapobiega wyswietlaniu liczbom
                              podzielnym przez 4 */
    printf ("%d, ", i); 
} 
			\end{lstlisting}
		\item \verb*|EXIT| - zakańcza działanie programu zwracając kod błędu. Kod 0 oznacza poprawne wykonanie programu.
		\begin{lstlisting}[language=C]
exit(0);
		\end{lstlisting}
				\end{itemize}
				
			\newpage\subsection{Zarządzanie pamięcią w języku C.}
				\subparagraph{Zarządzanie pamięcią} odbywa się za pomocą 3 możliwych operacji: alokacja, zmiana rozmiaru, wzolnienie pamięci. Ważne jest prawidłowe operowanie zwalnianiem pamięci, ponieważ błędy programistyczne na tej płaszczyźnie mogą doprowadzić do powstania zaalokowanych bloków pamięci, do których program nie ma już odwołania (wyciek pamięci). Wycieki pamięci powodują stałe ograniczenie zasobu pamięci na czas wykonywania programu, co może prowadzić do spowolnienia programu a nawet niepowodzenia w jego wykonaniu.\\
				
				Możwile operacje zarządzania pamięcią w języku C to:
				\begin{itemize}
					\item \verb*|malloc| - przydziela obszar pamięci o podanym rozmiarze i zwraca do niego “surowy” wskaźnik. Aby było wiadomo jaki typ danych znajduje się pod podanym adresem należy podać typ używany do konwersji (podawany w nawiasie przed formułą). Świeżo zajęta pamięć oczywiście zawiera “śmieci” - losowe wartości. \\Podajemy ilość bajtów jaką chcemy zająć.
					\begin{lstlisting}[language=C]
int* x = (int*) malloc(sizeof(int)); 
int* tab = (int*) malloc(sizeof(int)*n);
					\end{lstlisting}
					\item \verb*|calloc| - robi to samo co malloc, ale uzupełnia każdy zaalokowany adres wartością 0. Przydatne jeżeli potrzebujemy tablicy z zerami, albo wstaźnika na pojedynczą zmienną 0. \\Podajemy następująco: ilość elementów, wielkość każdego elementu w bajtach.
					\begin{lstlisting}[language=C]
int* tab = (int*) calloc(10,sizeof(int));
					\end{lstlisting}
					\item \verb*|realloc| - zmienia rozmiar wcześniej zaalokowanej pamięci. Nowo zaalokowana pamięć będzie miała najprawdopodobniej inny adres od pierwowzoru - będzie kopią (zależy od kompilatora).\\Podajemy następująco: wskaźnik i nowy rozmiar.
					\begin{lstlisting}[language=C]
int* tab = (int*) realloc(tab,sizeof(int)*n); 
					\end{lstlisting}
					\item \verb*|free| - służy do zwalniania dynamicznie zaalokowanej pamięci. Uwaga! Zwalnianie pamięci nie jest rekurencyjne, więc kolejność zwalniania ma znaczenie, aby nie doprowadzić do wycieków pamięci najpierw chcemy zwolnić elementy najniżej w hierarchii idąc w górę. Dla przykładu mając dynamicznie zaalokowaną klasę i jej atrybuty, chcemy zacząć od atrybutów i na końcu zwolnić pamięć jaką zajmuje element klasy.\\Podajemy wskaźnik na zmienną.
					\begin{lstlisting}[language=C]
free(tab);
					\end{lstlisting}
				\end{itemize}
			\newpage\subsection{Budowa, obsługa i formatowanie łańcuchów znakowych w języku C.}
				\subparagraph{Łańcuchy znaków}są to tablice zmiennych typu char, ostatni element tablicy to "\textbackslash0". Za ich pomocą reprezentowane są napisy. Napis 5-cio literowy musi być reprezentowany w co najmniej 6-cio elementowej tablicy (możliwa jest jego reprezentacja w dłuższej tablicy pod warunkiem zakończenia napisu symbolem - \textbackslash0).\\
					
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.45]{example_string_c.jpg}
					\caption{Przykład reprezentacji napisu "Hello"}
				\end{figure}
			
				\subsubsection{Budowa}

					Przykłady deklaracji łańcucha znakowego:
					\begin{itemize}
						\item przykład 1:
						\begin{lstlisting}[language=C]
char string1[] = "A string declared as an array.\n";
						\end{lstlisting}
						\item przykład 2:
						\begin{lstlisting}[language=C]
char *string2 = "A string declared as a pointer.\n";	
						\end{lstlisting}
						\item przykład 3:
						\begin{lstlisting}[language=C]
char string3[30]; 
strcpy(string3, "A string constant copied in.\n");
						\end{lstlisting}
					\end{itemize}
					\newpage
					Możliwe jest również dynamiczne zaalokowanie łańcucha, przykład:
					\begin{lstlisting}[language=C]
	char **tab = (char**)malloc(sizeof(char*) * 3); 
	/* 3 lancuchy znakow */
	for (int i=0; i<3; i++){ 
	    tab[i] = (char*)malloc(sizeof(char) * 200);
	    /* Po 200 bajtow na lancuch */
	} 
	strcpy(tab[0], "abcxyz"); 
	strcpy(tab[1], "zzzzzyyyyxxx"); 
	strcpy(tab[2], "ab123"); 
	printf("%s %s %s\n", tab[0], tab[1], tab[2]); 
					\end{lstlisting}
			
				\subsubsection{Obsługa łańcuchów}
					Do odsługi łańcuchów możemy zaliczyć następujące komendy:
					\begin{itemize}
						\item \verb*|strcmp| - służy do porównywania łańcuchów znaków. Jego działanie jest lekko odwrotne niż możnaby się spodziewać, ponieważ zwrócona wartość 0 oznacza identyczność łańcuchów. Funkcja zwraca wartość >0 jeżeli pierwszy nieidentyczny znak jest większy (wartościowo po ASCII) w pierwszym napisie. Analogicznie zwrócona wartośc ujemna oznacza, że pierwszy różny znak był mniejszy wartościowo (po ASCII) w pierwszym napisie.
						\begin{lstlisting}[language=C]
if (strcmp(A, B) == 0){
    /* lancuchy sa identyczne */
}
else if (strcmp(A, B) > 0){
    /* lancuch A jest wiekszy w kolejnosci alfabetycznej */
}
else /* (strcmp(A, B) < 0) */{
    /* lancuch A jest mniejszy w kolejnosci alfabetycznej */
}
						\end{lstlisting}
					\end{itemize}
				
				\subsubsection{Formatowanie łańcuchów}
					Istnieje możliwość sparametryzowania istaniejących łańcuchów, w celu tym wykorzystuje się wstawki typu \verb*|%.2f|, gdzie po nich podawana jest wartośc. Niektóre ze wstawek mogą być modyfikowane np. \verb*|%.2f| to tak naprawdę zmodyfikowana \verb*|%f|, liczba zmiennoprzecinkowa zostala ograniczona do 2 miejsc po przecinku.\\
					
					Możliwe wstawki to:
					\begin{itemize}
						\item \verb*|s| - wypisuje cały string (wypisuje całą tablicę typu char do symbolu końca linii)
						\begin{lstlisting}[language=C]
printf("Ciag znakow ASCII: %s", "jakis tekst"); 
						\end{lstlisting}
						\item \verb*|c| - int podany w argumencie zostanie zamieniony na znak ASCII
						\begin{lstlisting}[language=C]
printf("Znak ASCII o kodzie 65: %c", 65);
						\end{lstlisting}
						\item \verb*|d| - wypisuje liczbę w postaci dziesiętnej
						\begin{lstlisting}[language=C]
printf("Liczba dziesietna calkowita ze znakiem: %d", -65); 
						\end{lstlisting}
						\item \verb*|e| - liczba jest przedstawiana w postaci naukowej gdzie 0,45 to 4,5E-2
						\begin{lstlisting}[language=C]
printf("Liczba dziesietna w zapisie naukowym: %e", -165.1235); 
						\end{lstlisting}
						\item \verb*|f| - liczba (dziesiętna) jest przedstawiana w postaci zmiennoprzecinkowej
						\begin{lstlisting}[language=C]
printf("Liczba dziesietna zmiennoprzecinkowa: %f", -165.1235);
						\end{lstlisting}
						\item \verb*|o| -  liczba dziesiętna przedstawiona w systemie ósemkowym
						\begin{lstlisting}[language=C]
printf("Liczba osemkowa calkowita bez znaku: %o", 64); 
						\end{lstlisting}
						\item \verb*|u|- liczba (dodatnia, ujemna, zmiennoprzecinkowa) jest jako naturalna
						\begin{lstlisting}[language=C]
printf("Liczba dziesietna calkowita bez znaku: %u", 65);
						\end{lstlisting}
						\item \verb*|x| - liczba dziesiętna przedstawiona w systemie szesnastkowym
						\begin{lstlisting}[language=C]
printf("Liczba szesnastkowa bez znaku: %x", 346874); 
						\end{lstlisting}
					\end{itemize}
					
				
				
			\newpage\subsection{Zasięg i czas życia obiektów w języku C++.}
				\subparagraph{Zacięg i czas życia}to elementy charakteryzujące okres życia każdaj zmiennej. Zasięg opisuje w jakim obrębie programu umożliwiony jest dostęp do zmiennej. Czas życia rozpoczyna się w miejscu alokacji zmiennej i trwa aż do momentu jest jawnego lub (częściej) niejawnego zdealokowania. W przypadku zmiennych zaalokowanych niedynamicznie ich zycie dopiega końca gdy program nie ma już dostępu do ich zasięgu.\\
				
				Zniemme zaalokowane w sposób dynamiczny (wskaźniki) muszą zostać manualnie zwolnione za pomocą \verb*|free| (C i C++) lub \verb*|del| (C++).\\
				
				Zasięg zmiennej można podzielić na:
				\begin{enumerate}
					\item \textbf{Zasięg głobalny} - (inaczej mówiąc dla całego programu) to zasięg zmiennej lub obiektu w całym pliku. Najczęściej gdy programy są pisane w postaci skryptu jako 1 plik w którym to takie zmienne są inicjalizowane na czas całego programu.
					\item \textbf{Zasięg lokalny} - zakres zainicjalizowanych zmiennych bądź obiektów w bloku ogranicza się do tego bloku. Dotyczy to zwykłych bloków ( \{ \} ), pętli oraz warunków.
					\item \textbf{Zasięg w ciele funkcji} - czas życia zmiennych oraz obiektów ogranicza się do czasu wykonywania funkcji. Poza nią zmienne są niedostępne, a po jej zakończeniu zwalniane.
				\end{enumerate}
			\newpage\subsection{Obsługa wyjątków w języku C++.}
				\subparagraph{Obsługa wyjątków}to nic innego jak typowa struktura "try - catch". Struktura ta zamyka wybrany zakres kodu w bloku \verb*|TRY|. W przypadku niepowodzenia wykonania bloku try wykonywany jest kod z bloku \verb*|CATCH|. Zazwyczaj w bloku \verb*|CATCH| następuje wyświetlenie błędu, wykonanie alternatywnej operacji do tej w bloku \verb*|TRY| lub zakończenie programu.\\
				
				Po bloku \verb*|TRY| może występować wiele bloków \verb*|CATCH| z różnymi warunkami, warunki są sprawdzane po kolei i w wypadku natrafienia na pasujący wyjątek, wykonywany jest kod z tego bloku \verb*|CATCH|.\\
				\begin{lstlisting}[language=C]
try{  // boimy sie niepowodzenia operacji fun() i fun2()
    fun(); 
    fun2(); //podejrzane funkcje 
} 
catch(std::string obj) 
{ 
    /* tutaj mozemy wyswietlic blad
     lub wywolac alternatywne operacje */
}
				\end{lstlisting}
				
				Wyjątki mogą byś samodzielnie wywołane używając instrukcji \verb*|throw|.
				\begin{lstlisting}[language=C]
try 
{ 
    throw 123; 
} 
catch(int w) 
{ 
    cout << w << endl; /* wypisze: 123 */
} 

				\end{lstlisting}
			
			\newpage\subsection{Definicje obiektu, klasy i szablonu klasy w języku C++.}
				\subparagraph{Obiekt}to pojedyncza instancja konkretnej klasy. Każdy obiekt może posiadać atrybuty z unikalnymi wartościami np. (waga=59; wiek=24; kolor=różowy).\\
				
				\subparagraph{Klasa}to szablon (przepis) na podstawie którego powstają obekty. Klasa może posiadać atrybuty (zmienne) oraz metody (funkcje) różnego typu dostępu. Możliwe są typy:
				\begin{itemize}
					\item \verb*|PRYWATNY (private)| - brak bezpośredniego dostępu poza danym obiektem
					\item \verb*|CHRONIONY (protected)| - jak private lecz dostęp do elementów klasy jest możliwy dodatkowo z klas dziedziczących po tej klasie.
					\item \verb*|PUBLICZNY (public)| - nieograniczony dostęp, jeżeli mamy dostęp do obiektu to i do jego wszystkich elementów typu public.
				\end{itemize}
			
				Wśród klas można dodatkowo wyodręblić metody wirtualne deklarowane za pomocą instrukcji \verb*|virtual|, np.
				\begin{lstlisting}[language=C]
	virtual void a() = 0;
				\end{lstlisting}
				Metody wirtualne nie posiadają ciała.\\
				
				Klasy zawierające co najmniej 1 metodę wirtualną to klasy abstrakcyjne, nie można tworzyć za ich pomocą obiektów i służą jedynie do dziedziczenia.\\
				
				Specjalną klasą abstrakcyjną jest interfejs - klasa zawierająca \textbf{jedynie} metody wirtualne.
				
				
				\subparagraph{Szablon klasy}to pewnego rodzaju wzorzec do tworzenia klas. Szczególnie użyteczny w przypadku gdy planowane klasy różnią się jedynie typem atrybutów. Stosowanie szablonów pozwala zminimalizować powtarzalność kodu.\\
				
				Deklaracja szablonu:
				\begin{lstlisting}[language=C]
	template <typename T>
				\end{lstlisting}
			
				Przykład szablonu klasy:
				\begin{lstlisting}[language=C]
	class Punkt 
	{ 
	    public: 
	    Punkt( T argX, T argY, T argZ ) 
	    : x(argX), y(argY), z(argX) 
	    { } 
	    T x, y, z; 
	};
				\end{lstlisting}
			
				Wykorzystanie szablonu podczas tworzenia obiektu klasy: 
				\begin{lstlisting}[language=C]
	Punkt<int> A(0, -10, 0); 
	Punkt<float> A(0.4, 10.5, 5.1);
				\end{lstlisting}
		
		\newpage\section{Algosy}
			\subsection{Algorytmy sortujące.}
				\begin{enumerate}
					\item Sortowanie bąbelkowe - polega na porównywaniu par (sąsiednich) elementów. Za
					każdym przejściem zbioru elementu przynajmniej jeden jest już na swoim miejscu
					(takie wypychanie na zewnątrz). Złożoność obliczeniowa: $O(n^2)$
					\item Sortowanie przez wybieranie - polega na przeszukiwaniu zbioru elementów w
					poszukiwaniu najmniejszego (lub największego elementu). Po znalezieniu
					minimalnego elementu jest on zamieniany miejscami z elementem na pierwszym
					miejscu. Kolejny wyszukany element zostanie wstawiony na 2 miejsce, itd. Złożoność
					obliczeniowa:$O(n^2)$
					\item Sortowanie przez wstawianie - polega on na tworzeniu zbioru uporządkowanego ze
					zbioru nieuporządkowanego. Podczas tworzenia zbioru uporządkowanego pobiera
					się jeden element ze zbioru nieuporządkowanego i przeszukuje się zbiór
					uporządkowany w celu znalezienia odpowiedniego miejsca dla tego elementu.
					Można to porównać do sortowania kart do gry w ręce. Złożoność obliczeniowa:$O(n^2)$
					\item Sortowanie grzebieniowe - podobny do sortowania bąbelkowego lecz
					porównywane elementy mają między sobą pewien odstęp. Po każdym przejściu
					algorytmu ten odstęp się zmniejsza aż do uzyskania sortowania bąbelkowego (na
					początku sortuje “z grubsza”, a na koniec dokładnie). Złożoność obliczeniowa:$O(n^2)$
					\item Sortowanie Shella - basuje on na sortowaniu przez wstawianie. Ten algorytm dzieli
					zbiór na podzbiory (podana jest wartość informująca o odstępie między elementami
					podzbioru) gdzie na każdym z nich wykonywane jest sortowanie przez wstawianie.
					Za każdym obrotem odstęp się zmniejsza (jaki liczba podzbiorów), aby na końcu
					mieć już zwykłe sortowanie przez wstawianie. W zależności od odstępów złożoność
					obliczeniowa jest między:$O(n^2) - O(n\cdot\log n)$
					\item Quicksort - polega on na wybraniu jednego elementu ze zbioru i podzieleniu całego
					zbioru na elementy mniejsze od wybranego i większe od wybranego. Na dalszym
					etapie te same operacje są wykonywane na mniejszym podzbiorze. Działa ten
					algorytm póki nie będzie jednoelementowych zbiorów. Złożoność obliczeniowa
					(pesymistyczna): $O(n^2)$. W praktyce złożoność obliczeniowa jest bliska: $O(n\cdot\log n)$
					\item Mergesort - polega on na podziale zbioru na jednoelementowe zbiory. Podczas
					łączenia porównuje pierwsze elementy z dwóch zbiorów (bo te zbiory już są
					uporządkowane) i wybiera z ary odpowiedni. Potem bierze kolejny element ze zbioru
					i porównuje z drugim. Działa tak dopóki nie nie zostaną opróżnione dwa zbiory i nie
					powstanie jeden większy zbiór. Działa on na oraz większych zbiorach, aż do
					całkowitego posortowania pierwotnego zbioru. Złożoność obliczeniowa:$O(n\cdot\log n)$
					\item Sortowanie kubełkowe - polega na sortowaniu zbiorów o małym zakresie
					rozpiętości między wartościami skrajnymi. Po znalezieniu wartości skrajnych
					tworzona jest tablica gdzie indeks tablicy odpowiada wartości, a wartość tablicy ilości
					występowania elementu w zbiorze. Po przejściu zbioru i zliczeniu elementów
					uzyskuje się zbiór uporządkowany. Złożoność obliczeniowa: $O(n)$.
					\item Sortowanie pozycyjne - polega on na sortowaniu wartości według jakiejś pozycji,
					np. na początku występuje sortowanie według liczb jedności, potem dziesiątek, itd.
					Ważne jest aby to sortowanie było stabilne czyli nie zamienia miejscami elementów o
					równej wartości. Złożoność obliczeniowa: O(n*d). Często redukuje się do:$O(n\cdot\log n)$
					\item Sortowanie przez kopcowanie - polega on na utworzeniu (na początku) ze zbioru
					elementów struktury kopca. Następnie korzeń kopca jest zamieniany z ostatnim
					elementem (a sam kopiec jest zmniejszany o 1 element). W tym momencie należy
					przywrócić strukturę kopca (zamieniając ojca z większym synem dopóki ojciec nie
					będzie większy od synów). Potem znowu jest usuwany korzeń kopca dzięki czemu
					na końcu uzyska się zbiór uporządkowany. Złożoność obliczeniowa:$O(n\cdot\log n)$
				\end{enumerate}
			\newpage\subsection{\color{red}Algorytmy zachłanne.}
				a
			\newpage\subsection{\color{red}Metoda ,,dziel i zwyciężaj'' konstruowania algorytmów.}
				a
			\newpage\subsection{\color{red}Struktura kopców binarnych.}
				a
			\newpage\subsection{\color{red}Algorytmy wyszukiwania najkrótszej ścieżki w grafie.}
				a
			\newpage\subsection{\color{red}Sposoby implementacji słownika.}
				a
			\newpage\subsection{\color{red}Tablice mieszające.}
				a
			\newpage\subsection{\color{red}Algorytmy Monte Carlo oraz algorytmy Las Vegas.}
				a
			\newpage\subsection{\color{red}Metody reprezentacji grafów w komputerze.}
				a
			\newpage\subsection{\color{red}Droga i cykl Eulera. Droga i cykl Hamiltona.}
				a
			\newpage\subsection{\color{red}Drzewo spinające graf.}
				a
		
		\newpage\section{Teoria obliczalności czy coś}
			\subsection{\color{red}Pojęcia P, NP, NP-zupełne.}
				a
			\newpage\subsection{\color{red}Metody rozwiązywania rekurencji. Rekurencje Flawiusza i wieża w Hanoi.}
				a
			\newpage\subsection{\color{red}Algorytmy Euklidesa. Algorytmy faktoryzacji.}
				a
		
		\newpage\section{Automaty i inne takie}
			\subsection{\color{red}Deterministyczne i niedeterministyczne automaty skończone.}
				a
			\newpage\subsection{\color{red}Automaty z epsilon przejściami, wyrażenia regularne.}
				a
			\newpage\subsection{\color{red}Kompilacja: gramatyka bezkontekstowa, skaner, parser, błędy.}
				a
		
		\newpage\section{Podstawy komputera i systemy operacyjne}
			\subsection{\color{red}Systemy liczbowe i konwersje pomiędzy nimi.}
			
				a
				
			\newpage\subsection{Sposoby cyfrowej reprezentacji liczby całkowitej i rzeczywistej.}
			
				\subsubsection{Liczby całkowite}
				
				\subparagraph{Kod \text{ZM} (kod znak-moduł)}
				
				Sprawa w kodzie ZM jest w miarę prosta i klarowna. Najstarszy bit $b_{n-1}$ dla n-bitowej liczby jest bitem znaku i określa czy liczba jest dodatnia czy ujemna:
				\begin{itemize}
					\item 0 - liczba dodatnia,
					\item 1 - liczba ujemna.
				\end{itemize}
				
				Bity od $b_{n-1}$ do $b_0$ odpowiadają za kodowanie wartości samej liczby. Wzór na obliczenie wartości liczby zakodowanej w \textbf{ZM}:
				\begin{center}
					$L_{ZM} = (-1)^{b_{n-1}} \cdot (b_{n-2}2^{n-2} + ... + b_22^2 + b_12^1 + b_02^0)$
				\end{center}
				
				Przykładowe kodowanie liczby na ośmiu bitach w kodzie \textbf{ZM}:
				\begin{center}
					$26 \longrightarrow \textbf{0}0011010 $\\
					$-26 \longrightarrow \textbf{1}0011010 $
				\end{center}
				
				Proste, logiczne, fajne. Pytania, problemy? To jedziemy dalej.
				
				
				\subparagraph{Kod \textbf{U2} (kod uzupełnień do 2)}
				
				Tutaj sprawa się nieco komplikuje z zapisem liczb ujemnych. Bit $b_{n-1}$ ma wagę $-2^{n-1}$ co sprawia, że musimy bitowo tak jakby zapisać odwrotność liczby, którą chcemy reprezentować jako ujemna (i dodać 1, żeby się wszystko zgadzało). W zapisie liczb dodatnich zapis jest identyczny jak w \textbf{ZM} - na najstarszym bicie musimy tylko zachować $0$.
				
				Istnieje prosty algorytm konwersji na U2 z wykorzystaniem ZM:
				\begin{enumerate}
					\item Zapisać moduł liczby w ZM,
					\item Dokonać inwersji bitów (0 na 1 i 1 na 0),
					\item Zwiększ wynik dodając 1.
				\end{enumerate}
				
				Przykład z liczbą -27 na 8 bitach:
				
				\begin{tikzpicture}[x=2.2cm,y=1.4cm]
					\node[text width=5cm] at (0, 0)   (a) {Zapisujemy liczbę 27 w ZM};
					\node[text width=3cm] at (0.5, 1)   (b) {$00011011$};
					\draw [-to] (0,0.2) -- (0.2,0.7);
					\node[text width=3cm] at (2, 1)   (b) {$11100100$};
					\node[text width=3cm] at (3.5, 1)   (b) {$\textbf{11100101}$};
					
					\draw [-to] (0.7,1) -- (1.2,1);
					\draw [-to] (2.2,1) -- (2.7,1);
					
					\node[text width=5cm] at (2, 2)   (a) {Odwracamy bity};
					\draw [-to] (1.7,1.8) -- (1.7,1.2);
					
					\node[text width=5cm] at (3.9, 0)   (a) {Dodajemy 1};
					\draw [-to] (3.2,0.2) -- (3.2,0.7);
				\end{tikzpicture}
				
				\subsubsection{Liczby rzeczywiste}
				
				\subparagraph{Zapis stałopozycyjny}
				
				Do zapisu liczby stałoprzecinkowej przeznaczona jest z góry określona liczba bitów, a pozycję przecinka ustala się
				arbitralnie, w zależności od wymaganej dokładności, wolne bity uzupełniając zerami. Do reprezentacji liczb ze
				znakiem stosuje także kod U2.
				
				Liczba $6,25=110,01_{(2)}$ zapisana na 8 bitach gdy częśd ułamkowa zajmuje 3 najmłodsze bity, ma postać:
				\begin{center}
					\begin{tikzpicture}[x=2.2cm,y=1.4cm]	
						\node[text width=3cm] at (0, 0)   (b) {$\underbrace{00110}_{\text{część całkowita}}$};
						\node[text width=3cm] at (0.39, 0.42)   (b) {$\overbrace{010}^{\text{część ułamkowa}}$};
					\end{tikzpicture}
				\end{center}
				
				A w reprezentacji U2 będzie miała postać:
				
				\begin{center}
					$11001110$
				\end{center}
				
				Część całkowita liczby zachowuje się identycznie jak w przypadku zwykłych liczb całkowitych, natomiast bity w części ułamkowej posiadają wagi $2^{-1}$, $2^{-2}$, itd. - czyli $\frac{1}{2}$, $\frac{1}{4}$, ..., więc ilość bitów w części ułamkowej wpływa na precyzję zapisu.
				
				\subparagraph{Zapis zmiennopozycyjny}
				
				Liczba zmiennoprzecinkowa jest komputerową reprezentacją liczb rzeczywistych zapisanych w postaci wykładniczej
				o podstawie 2. Przykładowa notacja:
				
				\begin{center}
					$(-1)^Z \cdot M \cdot 2^C = (-1)^Z \cdot (1+m) \cdot 2^{c - BIAS}$
				\end{center}
				gdzie:
				\begin{description}
					\item[$(-1)^Z$] - znak liczby
					\item[$M=1+m$] - znormalizowana mantysa (liczba spełniająca warunek: $1 \leq M \leq 2$). Ponieważ przed przecinkiem stoi zawsze 1, więc można ją przedstawić w postaci $1+m$, gdzie \emph{m} jest liczbę ułamkową: $0 \leq m \leq 1$)
					\item[$C=c-BIAS$] - cecha (liczba całkowita), która dzięki zastosowaniu stałej BIAS pozwoli przedstawid cechę w postaci
					różnicy c-BIAS (c jest liczbą całkowitą dodatnią, tzw spolaryzowana cechę)
					\item[$BIAS$] - stała (liczba całkowita BIAS zależna od danej implementacji – rozwiązuje problem znaku cechy)
				\end{description}
				Kodujemy wyłącznie:
				\begin{description}
					\item[z] - bit znaku
					\item[m] - mantysę pomniejszoną o 1
					\item[c] - cechę przesuniętą o BIAS
				\end{description}
				
				Załóżmy, że operujemy następującym zmiennopozycyjnym formatem zapisu liczby rzeczywistej:
				\begin{itemize}
					\item na zapis przeznaczamy 16 bitów
					\item najstarszy bit ($b_{15}$) to bit znaku (będziemy stosowad kod ZM)
					\item kolejne 6 bitów ($b_{9}$-$b_{14}$) to mantysa
					\item pozostałe bity ($b_0$-$b_8$) są przeznaczone na zapis cechy i przyjmijmy, że BIAS=9
				\end{itemize}
				
				Przedstawimy liczbę +0,0224609375 w powyższym formacie. Naszą liczbę zapisujemy w systemie binarnym w
				postaci wykładniczej o podstawie 2, przesuwamy przecinek zapisując ją w notacji wykładniczej:
				
				\begin{center}
					$0,0224609375 = 0,0000010111_{(2)} = 1,0111_{(2)} \cdot 2^{-6}$
				\end{center}
				
				Z tego wynika, że:
				
				\begin{itemize}
					\item Znak: $(-1)^0$
					\item Mantysa: $1.\textbf{\underline{0111}}_2$
					\item Cecha: $-6 = 3-9 = 11_2 - BIAS$
				\end{itemize}
				
				Oto liczba 0,0224609375 zapisana w zadanym formacie:
				\begin{center}
					\begin{tikzpicture}[x=2.2cm,y=1.4cm]	
						\node[text width=3cm] at (0, 0)   (b) {$\underbrace{0}_{\text{bit znaku}}$};
						\node[text width=3cm] at (0.38, 0.39)   (b) {$\overbrace{011100}^{\text{mantysa}}$};
						\node[text width=3cm] at (1, 0)   (b) {$\underbrace{000000011}_{\text{cecha}}$};
					\end{tikzpicture}
				\end{center}
			
			\newpage\subsection{\color{red}Wielowarstwowa organizacja oprogramowania komputera.}
				a
			\newpage\subsection{\color{red}Procesy, zasoby i wątki.}
				a
			\newpage\subsection{\color{red}Planowanie przydziału procesora, priorytety, wywłaszczanie oraz planowanie.}
				a
			\newpage\subsection{\color{red}Zarządzanie pamięcią operacyjną.}
				a
			\newpage\subsection{\color{red}Problem zakleszczenia, algorytm Bankiera.}
				a
		
		\newpage\section{Inżynieria Oprogramowania}
			\subsection{\color{red}Standardowe metodyki procesu wytwórczego oprogramowania.}
				a
			\newpage\subsection{\color{red}Metodyki zwinne (agile).}
				\subparagraph{Programowanie zwinne (agile)} - są to metodyki wytwarzania oprogramowania które są
				oparte na programowaniu iteracyjno-przyrostowym oraz na obserwowaniu czy wymagania
				nie ewolują.
				
				Cechy:
				\begin{itemize}
					\item przeznaczony głównie dla małych zespołów programistycznych
					\item w zespołach nie występuje hierarchia
					\item zespoły same się organizują
					\item komunikacja jest jednym z głównych elementów podczas produkcji oprogramowania
					\item szybkie wytwarzanie oprogramowania (i dobrej jakości)
					\item oprogramowanie jest dostarczane cyklicznie
					\item mała ilość dokumentacji
				\end{itemize}
			
				Manifest Agile (ważniejsze > mniej ważne [ale występuje]):
				\begin{itemize}
					\item Ludzie i interakcje > Procesy i narzędzia
					\item Działające oprogramowanie > Obszerna dokumentacja
					\item Współpraca z klientem > Formalne ustalenia
					\item Reagowanie na zmiany > Podążanie za planem
				\end{itemize}
		
				Etapy Agile:
				\begin{enumerate}
					\item Planowanie - zbieranie wymagań klienta i ich analiza (kluczowa jest umiejętność
					dobrej komunikacji z klientem)
					\item Projektowanie - polega na przemyśleniu jak wykonać zaplanowany element
					\item Programowanie
					\item Testowanie
					\item Informacja zwrotna - zgłaszanie niewykrytych błędów, nowych pomysłów i zmian
					wymagań klienta
				\end{enumerate}
			
				\subsubsection{Metodyki zwinne}
				\begin{enumerate}
					\item XP (eXtreme Programming)
					\begin{itemize}
						\item stosowany w małych i średnich projektach “wysokiego ryzyka” (czyli takich
						gdzie nie wiadomo do końca jak zrealizować dany cel)
						\item tutaj najpierw są pisane testy, a potem program
						\item na początku projekt ma za zadanie spełniać minimalne wymagania lecz
						potem jest rozwijany i z każdą iteracją (co kilka tygodni) następuje kontakt z
						klientem który wyraża swoja opinię (informację zwrotną)
						\item występuje kontakt klient-programista
						\item podstawą jest dobra komunikacja ustna w zespole (brak dokumentacji)
						\item programiści pracują parami (jeden pisze, a drugi poprawia i komentuje; po
						jakimś czasie następuje zamiana)
						\item kod jest wspólny dla wszystkich i każdy może coś zmienić
						\item brak dokładnej specyfikacji wymagań
						\item iteracja posiada 4 etapy (wykonywane równolegle, a nie po sobie) :
						Planowanie, Projektowanie, Programowanie, Testowanie					
					\end{itemize}
					\begin{figure}[h!]
						\centering\includegraphics[scale=0.8]{xp.png}
					\end{figure}
				
					\item Scrum
					\begin{itemize}
						\item iteracje wytwarzania oprogramowania są nazywane Sprintami (iteracja trwa
						najwyżej miesiąc)
						\item każdy sprint dodaje nową funkcjonalność (jak w większości metodyk)
						\item zespół się sam organizuje (podobnie jak w XP)
						\item występują tutaj codzienne 15 minutowe spotkania całego zespołu w celu
						omówienia projektu (co kto zrobił, co zamierza zrobić)
						\item Podczas produkcji występują 3 role:
						\begin{itemize}
							\item Development Team - to grupa od 3 do 9 osób która tworzy produkt
							\item Product Owner - osoba reprezentująca klienta (bierze ciągły udział
							podczas produkcji
							\item Scrum Master - osoba która wspiera zespół, pomaga gdy zespół o to
							poprosi, interweniuje gdy trzeba, pracuje z Product Ownerem (to taki
							opiekun)
						\end{itemize}
						\item proces wytwórczy:
						\begin{itemize}
							\item zbieranie listy wymagań i określanie cech systemu (czyli
							funkcjonalności istotnych z punktu widzenia klienta)
							\item Product Owner przedstawia priorytety i główny cel (z tych wymagań)
							\item (początek sprintu) wybieranie zadań o najwyższym priorytecie
							\item tworzenie oprogramowania (programiści sami wybierają które
							zagadnienia chcą robić [no z tych priorytetowych oczywiście]) z
							udziałem Product Ownera i występujące codzienne 15 minutowe
							spotkania
							\item (koniec sprintu) prezentowanie wyników ze sprintu
						\end{itemize}
					\end{itemize}
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.7]{scrum.png}
				\end{figure}
				\item TDD (Test-driven development)
				\begin{itemize}
					\item polega on na tym że na początku są pisane testy, a potem kod
					\item przydatny dla większych projektów (dla maych to jest strata czasu z pisaniem
					tych testów)
					\item etapy cyklu tworzenia oprogramowania:
					\begin{itemize}
						\item napisanie testów (które nie przechodzą przy braku implementacji)
						\item napisanie kodu które przejdzie test
						\item refaktoryzacja kodu
					\end{itemize}
					\item pisanie testów na początku zmniejsza ryzyko występowania błędów
					\item to jest technika “pierwsze testy, a potem kod” zmniejszający ryzyko
					występowania błędu, a gdy jest odwrotnie to nie dość że trzeba szukać błędu
					to i ilość kodu jest większa (od powstania błędu)
				\end{itemize}
				\begin{figure}[h!]
					\centering\includegraphics[scale=0.6]{tdd.png}
				\end{figure}
				\end{enumerate}
			\newpage\subsection{\color{red}Metody testowania oprogramowania.}
				a
			\newpage\subsection{\color{red}Walidacja i weryfikacja oprogramowania.}
				a
			\newpage\subsection{\color{red}Diagramy UML (przypadków użycia, klas, aktywności, sekwencji, stanów, obiektów, wdrożenia).}
				a
			\newpage\subsection{\color{red}Wzorce projektowe programowania obiektowego.}
				a
			\newpage\subsection{\color{red}Wzorce architektoniczne.}
				a
		
		\newpage\section{Systemy wbudowane i elektronika}
			\subsection{\color{red}Różnice pomiędzy obsługą zdarzeń w przerwaniach sprzętowych a obsługą zdarzeń w pętli programowej.}
				a
			\newpage\subsection{\color{red}Stosowalność systemów opartych o mikrokontrolery vs stosowalność typowych komputerów (stacjonarnych i laptopów).}
				a
			\newpage\subsection{\color{red}Dekoder, multiplekser i demultiplekser: budowa, zasada, działania, przeznaczenie/zastosowanie.}
				a
			\newpage\subsection{\color{red}Podstawowe układy budujące system mikroprocesorowy i sposób wymiany informacji pomiędzy nimi.}
				a
\end{document}